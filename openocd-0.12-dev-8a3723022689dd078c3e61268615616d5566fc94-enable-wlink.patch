diff -Nur openocd/configure.ac openocd.new/configure.ac
--- openocd/configure.ac	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/configure.ac	2024-11-23 18:26:09.668573019 +0800
@@ -122,6 +122,7 @@
 m4_define([USB1_ADAPTERS],
 	[[[ftdi], [MPSSE mode of FTDI based devices], [FTDI]],
 	[[stlink], [ST-Link Programmer], [HLADAPTER_STLINK]],
+	[[wlink], [WLink Programmer], [WLINK]],
 	[[ti_icdi], [TI ICDI JTAG Programmer], [HLADAPTER_ICDI]],
 	[[ulink], [Keil ULINK JTAG Programmer], [ULINK]],
 	[[angie], [ANGIE Adapter], [ANGIE]],
@@ -574,7 +575,11 @@
 ], [
   AC_DEFINE([BUILD_VDEBUG], [0], [0 if you don't want Cadence vdebug interface.])
 ])
-
+AS_IF([test "x$build_wlink" = "xyes"], [
+  AC_DEFINE([BUILD_WLINK], [1], [1 if you want WLINK.])
+], [
+  AC_DEFINE([BUILD_WLINK], [0], [0 if you don't want WLINK.])
+])
 AS_IF([test "x$build_jtag_dpi" = "xyes"], [
   AC_DEFINE([BUILD_JTAG_DPI], [1], [1 if you want JTAG DPI.])
 ], [
@@ -777,6 +782,7 @@
 AM_CONDITIONAL([AM335XGPIO], [test "x$build_am335xgpio" = "xyes"])
 AM_CONDITIONAL([BITBANG], [test "x$build_bitbang" = "xyes"])
 AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes"])
+AM_CONDITIONAL([WLINK], [test "x$build_wlink" != "xno"])
 AM_CONDITIONAL([VDEBUG], [test "x$build_vdebug" = "xyes"])
 AM_CONDITIONAL([JTAG_DPI], [test "x$build_jtag_dpi" = "xyes"])
 AM_CONDITIONAL([USB_BLASTER_DRIVER], [test "x$enable_usb_blaster" != "xno" -o "x$enable_usb_blaster_2" != "xno"])
diff -Nur openocd/src/flash/nor/core.c openocd.new/src/flash/nor/core.c
--- openocd/src/flash/nor/core.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/flash/nor/core.c	2024-11-23 18:12:06.616366684 +0800
@@ -725,13 +725,14 @@
 	target_addr_t aligned2 = flash_write_align_start(bank, addr2);
 	return aligned1 + bank->minimal_write_gap < aligned2;
 }
-
-
+uint8_t binbuf[1024*512];
+extern unsigned char riscvchip;
 int flash_write_unlock_verify(struct target *target, struct image *image,
 	uint32_t *written, bool erase, bool unlock, bool write, bool verify)
 {
 	int retval = ERROR_OK;
-
+	uint32_t startaddr;
+	unsigned long binlen;
 	unsigned int section;
 	uint32_t section_offset;
 	struct flash_bank *c;
@@ -739,7 +740,7 @@
 
 	section = 0;
 	section_offset = 0;
-
+	memset(binbuf,0xff,1024*512);
 	if (written)
 		*written = 0;
 
@@ -782,6 +783,7 @@
 
 		/* find the corresponding flash bank */
 		retval = get_flash_bank_by_addr(target, run_address, false, &c);
+		
 		if (retval != ERROR_OK)
 			goto done;
 		if (!c) {
@@ -790,7 +792,7 @@
 			section_offset = 0;
 			continue;
 		}
-
+		startaddr=sections[0]->base_address - c->base;
 		/* collect consecutive sections which fall into the same bank */
 		section_last = section;
 		padding[section] = 0;
@@ -963,11 +965,17 @@
 
 		if (retval == ERROR_OK) {
 			if (write) {
+				if(riscvchip){
+					memcpy((&binbuf[run_address- c->base]),buffer,run_size);
+				}else{
 				/* write flash sectors */
-				retval = flash_driver_write(c, buffer, run_address - c->base, run_size);
+					retval = flash_driver_write(c, buffer, run_address - c->base, run_size);
+				}
 			}
 		}
-
+		if(riscvchip){
+			binlen=run_address- c->base+run_size;
+		}
 		if (retval == ERROR_OK) {
 			if (verify) {
 				/* verify flash sectors */
@@ -985,7 +993,15 @@
 		if (written)
 			*written += run_size;	/* add run size to total written counter */
 	}
+	
+	if(!c){
+		return ERROR_FAIL;
+    }
+	if(riscvchip){		
+	
+	 flash_driver_write(c, &binbuf[startaddr], startaddr, (binlen-startaddr));
 
+	 }
 done:
 	free(sections);
 	free(padding);
diff -Nur openocd/src/flash/nor/driver.h openocd.new/src/flash/nor/driver.h
--- openocd/src/flash/nor/driver.h	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/flash/nor/driver.h	2024-11-23 18:15:56.135719190 +0800
@@ -297,6 +297,8 @@
 extern const struct flash_driver stm32h7x_flash;
 extern const struct flash_driver stm32l4x_flash;
 extern const struct flash_driver stm32lx_flash;
+extern const struct flash_driver wch_arm_flash;
+extern const struct flash_driver wch_riscv_flash;
 extern const struct flash_driver stmqspi_flash;
 extern const struct flash_driver stmsmi_flash;
 extern const struct flash_driver str7x_flash;
diff -Nur openocd/src/flash/nor/drivers.c openocd.new/src/flash/nor/drivers.c
--- openocd/src/flash/nor/drivers.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/flash/nor/drivers.c	2024-11-23 18:26:46.404687151 +0800
@@ -73,6 +73,8 @@
 	&stm32lx_flash,
 	&stm32l4x_flash,
 	&stm32h7x_flash,
+  	&wch_arm_flash,
+  	&wch_riscv_flash,
 	&stmsmi_flash,
 	&stmqspi_flash,
 	&str7x_flash,
diff -Nur openocd/src/flash/nor/Makefile.am openocd.new/src/flash/nor/Makefile.am
--- openocd/src/flash/nor/Makefile.am	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/flash/nor/Makefile.am	2024-11-23 18:17:32.345999388 +0800
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 noinst_LTLIBRARIES += %D%/libocdflashnor.la
+%C%_libocdflashnor_la_CPPFLAGS = $(AM_CPPFLAGS) -Wno-incompatible-pointer-types
 %C%_libocdflashnor_la_SOURCES = \
 	%D%/core.c \
 	%D%/tcl.c \
@@ -71,6 +72,8 @@
 	%D%/stm32lx.c \
 	%D%/stm32l4x.c \
 	%D%/stm32h7x.c \
+	%D%/wcharm.c \
+	%D%/wchriscv.c \
 	%D%/str7x.c \
 	%D%/str9x.c \
 	%D%/str9xpec.c \
diff -Nur openocd/src/flash/nor/tcl.c openocd.new/src/flash/nor/tcl.c
--- openocd/src/flash/nor/tcl.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/flash/nor/tcl.c	2024-11-23 18:16:57.977894396 +0800
@@ -19,6 +19,10 @@
  * Implements Tcl commands used to access NOR flash facilities.
  */
 
+extern int wlnik_protect_check(void);
+extern int riscvchip;
+extern int wlink_quitreset(void);
+
 COMMAND_HELPER(flash_command_get_bank_probe_optional, unsigned int name_index,
 	       struct flash_bank **bank, bool do_probe)
 {
@@ -388,7 +392,23 @@
 
 	return retval;
 }
+COMMAND_HANDLER(handle_flash_protect_check_command){
+	if(riscvchip==1)
+		wlink_quitreset();
+	if((riscvchip==1)||(riscvchip==5)||(riscvchip==6)||(riscvchip==9)){
+		int retval=wlnik_protect_check();
+		if(retval==4)
+			LOG_INFO("Code Read-Protect Status Enable");
+		else
+			LOG_INFO("Code Read-Protect status Disable");
+				
+	}else{
+		LOG_ERROR("This chip do not support function");
+		return ERROR_OK;
+	}
+
 
+}
 COMMAND_HANDLER(handle_flash_write_image_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
@@ -1229,6 +1249,13 @@
 		.usage = "bank_id value",
 		.help = "Set default flash padded value",
 	},
+	{
+		.name = "protect_check",
+		.handler = handle_flash_protect_check_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff -Nur openocd/src/flash/nor/wcharm.c openocd.new/src/flash/nor/wcharm.c
--- openocd/src/flash/nor/wcharm.c	1970-01-01 08:00:00.000000000 +0800
+++ openocd.new/src/flash/nor/wcharm.c	2024-11-23 18:12:06.616366684 +0800
@@ -0,0 +1,1091 @@
+/***************************************************************************
+ * 	 WCH ARM mcu :CH32F10X ;CH32F20X                                       *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+ 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+
+/* ch32x register locations */
+
+#define FLASH_REG_BASE_B0 0x40022000
+#define FLASH_REG_BASE_B1 0x40022040
+
+#define ch32_FLASH_ACR     0x00
+#define ch32_FLASH_KEYR    0x04
+#define ch32_FLASH_OPTKEYR 0x08
+#define ch32_FLASH_SR      0x0C
+#define ch32_FLASH_CR      0x10
+#define ch32_FLASH_AR      0x14
+#define ch32_FLASH_OBR     0x1C
+#define ch32_FLASH_WRPR    0x20
+#define CH32_FLASH_MODEKEYP 0x24 //chf103�����Ĵ���
+
+/* TODO: Check if code using these really should be hard coded to bank 0.
+ * There are valid cases, on dual flash devices the protection of the
+ * second bank is done on the bank0 reg's. */
+#define ch32_FLASH_ACR_B0     0x40022000
+#define ch32_FLASH_KEYR_B0    0x40022004
+#define ch32_FLASH_OPTKEYR_B0 0x40022008
+#define ch32_FLASH_SR_B0      0x4002200C
+#define ch32_FLASH_CR_B0      0x40022010
+#define ch32_FLASH_AR_B0      0x40022014
+#define ch32_FLASH_OBR_B0     0x4002201C
+#define ch32_FLASH_WRPR_B0    0x40022020
+
+/* option byte location */
+
+#define ch32_OB_RDP		0x1FFFF800
+#define ch32_OB_USER		0x1FFFF802
+#define ch32_OB_DATA0		0x1FFFF804
+#define ch32_OB_DATA1		0x1FFFF806
+#define ch32_OB_WRP0		0x1FFFF808
+#define ch32_OB_WRP1		0x1FFFF80A
+#define ch32_OB_WRP2		0x1FFFF80C
+#define ch32_OB_WRP3		0x1FFFF80E
+
+/* FLASH_CR register bits */
+
+#define FLASH_PG			(1 << 0)
+#define FLASH_PER			(1 << 1)
+#define FLASH_MER			(1 << 2)
+#define FLASH_OPTPG			(1 << 4)
+#define FLASH_OPTER			(1 << 5)
+#define FLASH_STRT			(1 << 6)
+#define FLASH_LOCK			(1 << 7)
+#define FLASH_OPTWRE		(1 << 9)
+#define FLASH_OBL_LAUNCH	(1 << 13)	/* except ch32f1x series */
+
+
+#define FLASH_PAGE_PROGRAM	  0x00010000	
+#define FLASH_PAGE_ERASE		  0x00020000	
+#define FLASH_STD_PAGE_ERASE  0x00000002  
+#define FLASH_STD_PAGE_PRG    0x00000001  
+#define FLASH_BUF_LOAD			  0x00040000	
+#define FLASH_BUF_RTS				  0x00080000	
+
+
+
+/* FLASH_SR register bits */
+
+#define FLASH_BSY		(1 << 0)
+#define FLASH_PGERR		(1 << 2)
+#define FLASH_WRPRTERR	(1 << 4)
+#define FLASH_EOP		(1 << 5)
+
+/* ch32_FLASH_OBR bit definitions (reading) */
+
+#define OPT_ERROR		0
+#define OPT_READOUT		1
+#define OPT_RDWDGSW		2
+#define OPT_RDRSTSTOP	3
+#define OPT_RDRSTSTDBY	4
+#define OPT_BFB2		5	/* dual flash bank only */
+
+/* register unlock keys */
+
+#define KEY1			0x45670123
+#define KEY2			0xCDEF89AB
+
+/* timeout values */
+
+#define FLASH_WRITE_TIMEOUT 10
+#define FLASH_ERASE_TIMEOUT 100
+
+struct ch32x_options {
+	uint8_t rdp;
+	uint8_t user;
+	uint16_t data;
+	uint32_t protection;
+};
+
+struct ch32x_flash_bank {
+	struct ch32x_options option_bytes;
+	int ppage_size;
+	int probed;
+
+	bool has_dual_banks;
+	/* used to access dual flash bank ch32xl */
+	bool can_load_options;
+	uint32_t register_base;
+	uint8_t default_rdp;
+	int user_data_offset;
+	int option_offset;
+	uint32_t user_bank_size;
+};
+
+uint8_t armchip;
+
+extern int wlink_armerase(void);
+extern int wlink_armwrite(const uint8_t *buffer,uint32_t offset, uint32_t count);
+extern int noloadflag;
+static int ch32x_mass_erase(struct flash_bank *bank);
+static int ch32x_get_device_id(struct flash_bank *bank, uint32_t *device_id);
+static int ch32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t address, uint32_t count);
+extern int wlink_armcheckprotect(void);
+extern void wlink_sendchip(uint8_t config);
+extern  bool wlink549;
+
+
+
+/* flash bank ch32x <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(ch32x_flash_bank_command)
+{
+	struct ch32x_flash_bank *ch32x_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	ch32x_info = malloc(sizeof(struct ch32x_flash_bank));
+
+	bank->driver_priv = ch32x_info;
+	ch32x_info->probed = 0;
+	ch32x_info->has_dual_banks = false;
+	ch32x_info->can_load_options = false;
+	ch32x_info->register_base = FLASH_REG_BASE_B0;
+	ch32x_info->user_bank_size = bank->size;
+
+	return ERROR_OK;
+}
+
+static inline int ch32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
+{
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+	return reg + ch32x_info->register_base;
+}
+
+static inline int ch32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
+{
+	struct target *target = bank->target;
+	return target_read_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_SR), status);
+}
+
+static int ch32x_wait_status_busy(struct flash_bank *bank, int timeout)
+{
+	struct target *target = bank->target;
+	uint32_t status;
+	int retval = ERROR_OK;
+
+	/* wait for busy to clear */
+	for (;;) {
+		retval = ch32x_get_flash_status(bank, &status);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("status: 0x%" PRIx32 "", status);
+		if ((status & FLASH_BSY) == 0)
+			break;
+		if (timeout-- <= 0) {
+			LOG_ERROR("timed out waiting for flash");
+			return ERROR_FAIL;
+		}
+		alive_sleep(1);
+	}
+
+	if (status & FLASH_WRPRTERR) {
+		LOG_ERROR("ch32x device protected");
+		retval = ERROR_FAIL;
+	}
+
+	if (status & FLASH_PGERR) {
+		LOG_ERROR("ch32x device programming failed");
+		retval = ERROR_FAIL;
+	}
+
+	/* Clear but report errors */
+	if (status & (FLASH_WRPRTERR | FLASH_PGERR)) {
+		/* If this operation fails, we ignore it and report the original
+		 * retval
+		 */
+		target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_SR),
+				FLASH_WRPRTERR | FLASH_PGERR);
+	}
+	return retval;
+}
+
+static int ch32x_check_operation_supported(struct flash_bank *bank)
+{
+	
+	
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+
+	/* if we have a dual flash bank device then
+	 * we need to perform option byte stuff on bank0 only */
+	if (ch32x_info->register_base != FLASH_REG_BASE_B0) {
+		LOG_ERROR("Option Byte Operation's must use bank0");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+static int ch32x_read_options(struct flash_bank *bank)
+{
+	
+	
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t option_bytes;
+	int retval;
+
+	/* read user and read protection option bytes */
+	retval = target_read_u32(target, ch32_OB_RDP, &option_bytes);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ch32x_info->option_bytes.rdp = option_bytes & 0xFF;
+	ch32x_info->option_bytes.user = (option_bytes >> 16) & 0xFF;
+
+	/* read user data option bytes */
+	retval = target_read_u32(target, ch32_OB_DATA0, &option_bytes);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ch32x_info->option_bytes.data = ((option_bytes >> 8) & 0xFF00) | (option_bytes & 0xFF);
+
+	/* read write protection option bytes */
+	retval = target_read_u32(target, ch32_OB_WRP0, &option_bytes);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ch32x_info->option_bytes.protection = ((option_bytes >> 8) & 0xFF00) | (option_bytes & 0xFF);
+
+	retval = target_read_u32(target, ch32_OB_WRP2, &option_bytes);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ch32x_info->option_bytes.protection |= (((option_bytes >> 8) & 0xFF00) | (option_bytes & 0xFF)) << 16;
+
+	return ERROR_OK;
+}
+
+static int ch32x_erase_options(struct flash_bank *bank)
+{
+	
+	
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+	struct target *target = bank->target;
+
+	/* read current options */
+	ch32x_read_options(bank);
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, ch32_FLASH_KEYR_B0, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, ch32_FLASH_KEYR_B0, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, ch32_FLASH_OPTKEYR_B0, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32_FLASH_OPTKEYR_B0, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* erase option bytes */
+	retval = target_write_u32(target, ch32_FLASH_CR_B0, FLASH_OPTER | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32_FLASH_CR_B0, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = ch32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* clear read protection option byte
+	 * this will also force a device unlock if set */
+	ch32x_info->option_bytes.rdp = ch32x_info->default_rdp;
+
+	return ERROR_OK;
+}
+
+static int ch32x_write_options(struct flash_bank *bank)
+{
+	
+	
+	struct ch32x_flash_bank *ch32x_info = NULL;
+	struct target *target = bank->target;
+
+	ch32x_info = bank->driver_priv;
+
+	/* unlock flash registers */
+	int retval = target_write_u32(target, ch32_FLASH_KEYR_B0, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32_FLASH_KEYR_B0, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, ch32_FLASH_OPTKEYR_B0, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32_FLASH_OPTKEYR_B0, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* program option bytes */
+	retval = target_write_u32(target, ch32_FLASH_CR_B0, FLASH_OPTPG | FLASH_OPTWRE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	uint8_t opt_bytes[16];
+
+	target_buffer_set_u16(target, opt_bytes, ch32x_info->option_bytes.rdp);
+	target_buffer_set_u16(target, opt_bytes + 2, ch32x_info->option_bytes.user);
+	target_buffer_set_u16(target, opt_bytes + 4, ch32x_info->option_bytes.data & 0xff);
+	target_buffer_set_u16(target, opt_bytes + 6, (ch32x_info->option_bytes.data >> 8) & 0xff);
+	target_buffer_set_u16(target, opt_bytes + 8, ch32x_info->option_bytes.protection & 0xff);
+	target_buffer_set_u16(target, opt_bytes + 10, (ch32x_info->option_bytes.protection >> 8) & 0xff);
+	target_buffer_set_u16(target, opt_bytes + 12, (ch32x_info->option_bytes.protection >> 16) & 0xff);
+	target_buffer_set_u16(target, opt_bytes + 14, (ch32x_info->option_bytes.protection >> 24) & 0xff);
+
+	retval = ch32x_write_block(bank, opt_bytes, ch32_OB_RDP, sizeof(opt_bytes) / 2);
+	if (retval != ERROR_OK) {
+		if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			LOG_ERROR("working area required to erase options bytes");
+		return retval;
+	}
+
+	retval = target_write_u32(target, ch32_FLASH_CR_B0, FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int ch32x_protect_check(struct flash_bank *bank)
+{
+	
+
+	struct target *target = bank->target;
+	uint32_t protection;
+
+	int retval = ch32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* medium density - each bit refers to a 4 sector protection block
+	 * high density - each bit refers to a 2 sector protection block
+	 * bit 31 refers to all remaining sectors in a bank */
+	retval = target_read_u32(target, ch32_FLASH_WRPR_B0, &protection);
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (int i = 0; i < bank->num_prot_blocks; i++)
+		bank->prot_blocks[i].is_protected = (protection & (1 << i)) ? 0 : 1;
+
+	return ERROR_OK;
+}
+
+static int ch32x_erase(struct flash_bank *bank, int first, int last)
+{	
+ if(armchip)
+ {
+	if(noloadflag)
+		return ERROR_OK;
+				
+	    int ret=wlink_armerase();
+		
+		return ret;
+			
+ }	
+}
+
+static int ch32x_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	printf("%d %d %d\n",set,first,last);
+	return ERROR_OK;
+	struct target *target = bank->target;
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	int retval = ch32x_check_operation_supported(bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = ch32x_erase_options(bank);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("ch32x failed to erase options");
+		return retval;
+	}
+
+	for (int i = first; i <= last; i++) {
+		if (set)
+			ch32x_info->option_bytes.protection &= ~(1 << i);
+		else
+			ch32x_info->option_bytes.protection |= (1 << i);
+	}
+
+	return ch32x_write_options(bank);
+}
+
+static int ch32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t address, uint32_t count)
+{
+	return ERROR_OK;
+}
+
+static int ch32x_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+ if(armchip)
+ {
+		if(noloadflag)
+				return ERROR_OK;			
+		int ret=wlink_armwrite(buffer,bank->base + offset,count);				
+		return ret;				
+ }
+
+}
+
+static int ch32x_get_device_id(struct flash_bank *bank, uint32_t *device_id)
+{
+	/* This check the device CPUID core register to detect
+	 * the M0 from the M3 devices. */
+ 
+	struct target *target = bank->target;
+	uint32_t cpuid, device_id_register = 0;
+    uint32_t testid=0;
+    uint32_t tmp,tmp1,tmp2=0;
+	uint8_t user_cfg,config;
+	target_read_u8(target, 0x1ffff802, &user_cfg);
+	config=user_cfg>>6;
+	target_read_u32(target, 0x1ffff884, &testid);
+	testid =testid >>16;
+	testid &=0xff00;
+	
+  	if((testid==0x2000)||(testid==0x1000)||(testid==0x3000)){
+  		// target_read_u32(target, 0x1ffff7e8, &tmp);
+  		// target_read_u32(target, 0x1ffff8a0, &tmp1);
+  		// if(tmp==tmp1){
+  			target_read_u32(target, 0x1ffff880, &tmp2);
+			
+  			  if(tmp2==0xdc78fe34)
+  			    armchip=1;
+  				*device_id=0x20000410;
+  				wlink_sendchip(config);
+  				return ERROR_OK;
+  		// }
+  	
+  	}
+  	target_read_u32(target, 0xe000edfc, &testid);
+ 
+  	target_read_u32(target, 0xe000edf0, &testid);
+  	
+  	target_read_u32(target, 0x1ffff704, &testid);
+  	
+  	if(((testid>>20)==0x203)||((testid>>20)==0x205)||((testid>>20)==0x207)||((testid>>20)==0x208)){	
+  		 	armchip=2;
+  			*device_id=0x20000410;
+  			wlink_sendchip(config);
+  			return ERROR_OK;
+		}
+	if((armchip != 1)&&(armchip != 2 ) && wlink549 ){
+		LOG_ERROR(" WCH-Link-CH549 does not support this chip, please use WCH-LinkE");
+		return ERROR_FAIL;
+	}
+	return ERROR_FAIL;
+}
+
+static int ch32x_get_flash_size(struct flash_bank *bank, uint16_t *flash_size_in_kb)
+{	
+	struct target *target = bank->target;
+	uint32_t cpuid, flash_size_reg;
+    uint32_t temp;
+	int retval = target_read_u32(target, 0x1ffff7e0, flash_size_in_kb);	
+	if (retval != ERROR_OK)
+		return retval;
+
+	return retval;
+}
+
+static int ch32x_probe(struct flash_bank *bank)
+{	
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+	uint16_t flash_size_in_kb;
+	uint16_t max_flash_size_in_kb;
+	uint32_t device_id;
+	int page_size;
+	uint32_t base_address = 0x08000000;
+    uint32_t rid=0;
+	ch32x_info->probed = 0;
+	ch32x_info->register_base = FLASH_REG_BASE_B0;
+	ch32x_info->user_data_offset = 10;
+	ch32x_info->option_offset = 0;
+
+	/* default factory read protection level 0 */
+	ch32x_info->default_rdp = 0xA5;	
+	
+  int retval = ch32x_get_device_id(bank, &device_id);
+	if (retval != ERROR_OK)
+		return retval;
+	
+	// LOG_INFO("device id = 0x%08" PRIx32 "", device_id);
+	rid=device_id & 0xfff ;
+	/* set page size, protection granularity and max flash size depending on family */
+	switch (device_id & 0xfff) {
+	case 0x410: /* medium density */
+		page_size = 1024;
+		ch32x_info->ppage_size = 4;
+		max_flash_size_in_kb = 512;
+		break;
+	
+	default:
+		LOG_WARNING("Cannot identify target as a ch32 family.");
+		return ERROR_FAIL;
+	}
+
+	/* get flash size from target. */
+	retval = ch32x_get_flash_size(bank, &flash_size_in_kb);
+
+	/* failed reading flash size or flash size invalid (early silicon),
+	 * default to max target family */
+	if (retval != ERROR_OK || flash_size_in_kb == 0xffff || flash_size_in_kb == 0) {
+		//LOG_WARNING("ch32 flash size failed, probe inaccurate - assuming %dk flash",
+			//max_flash_size_in_kb);
+		flash_size_in_kb = max_flash_size_in_kb;
+	}
+
+	if (ch32x_info->has_dual_banks) {
+		/* split reported size into matching bank */
+		if (bank->base != 0x08080000) {
+			/* bank 0 will be fixed 512k */
+			flash_size_in_kb = 512;
+		} else {
+			flash_size_in_kb -= 512;
+			/* bank1 also uses a register offset */
+			ch32x_info->register_base = FLASH_REG_BASE_B1;
+			base_address = 0x08080000;
+		}
+	}
+
+	/* if the user sets the size manually then ignore the probed value
+	 * this allows us to work around devices that have a invalid flash size register value */
+
+
+	LOG_INFO("flash size = %dkbytes", flash_size_in_kb);
+
+	/* did we assign flash size? */
+	assert(flash_size_in_kb != 0xffff);
+
+	/* calculate numbers of pages */
+	int num_pages = flash_size_in_kb * 1024 / page_size;
+
+	/* check that calculation result makes sense */
+	assert(num_pages > 0);
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	if (bank->prot_blocks) {
+		free(bank->prot_blocks);
+		bank->prot_blocks = NULL;
+	}
+
+	bank->base = base_address;
+	bank->size = (num_pages * page_size);
+
+	bank->num_sectors = num_pages;
+	bank->sectors = alloc_block_array(0, page_size, num_pages);
+	if (!bank->sectors)
+		return ERROR_FAIL;
+
+	/* calculate number of write protection blocks */
+	int num_prot_blocks = num_pages / ch32x_info->ppage_size;
+	if (num_prot_blocks > 32)
+		num_prot_blocks = 32;
+
+	bank->num_prot_blocks = num_prot_blocks;
+	bank->prot_blocks = alloc_block_array(0, ch32x_info->ppage_size * page_size, num_prot_blocks);
+	if (!bank->prot_blocks)
+		return ERROR_FAIL;
+
+	if (num_prot_blocks == 32)
+		bank->prot_blocks[31].size = (num_pages - (31 * ch32x_info->ppage_size)) * page_size;
+
+	ch32x_info->probed = 1;
+	wlink_armcheckprotect();
+	return ERROR_OK;
+}
+
+static int ch32x_auto_probe(struct flash_bank *bank)
+{
+	
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+	if (ch32x_info->probed)
+		return ERROR_OK;
+	return ch32x_probe(bank);
+}
+
+#if 0
+COMMAND_HANDLER(ch32x_handle_part_id_command)
+{
+	return ERROR_OK;
+}
+#endif
+
+static int get_ch32x_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ch32x_handle_lock_command)
+{
+	struct target *target = NULL;
+	struct ch32x_flash_bank *ch32x_info = NULL;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	ch32x_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = ch32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (ch32x_erase_options(bank) != ERROR_OK) {
+		command_print(CMD, "ch32x failed to erase options");
+		return ERROR_OK;
+	}
+
+	/* set readout protection */
+	ch32x_info->option_bytes.rdp = 0;
+
+	if (ch32x_write_options(bank) != ERROR_OK) {
+		command_print(CMD, "ch32x failed to lock device");
+		return ERROR_OK;
+	}
+
+	command_print(CMD, "ch32x locked");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ch32x_handle_unlock_command)
+{
+	struct target *target = NULL;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = ch32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (ch32x_erase_options(bank) != ERROR_OK) {
+		command_print(CMD, "ch32x failed to erase options");
+		return ERROR_OK;
+	}
+
+	if (ch32x_write_options(bank) != ERROR_OK) {
+		command_print(CMD, "ch32x failed to unlock device");
+		return ERROR_OK;
+	}
+
+	command_print(CMD, "ch32x unlocked.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ch32x_handle_options_read_command)
+{
+	uint32_t optionbyte, protection;
+	struct target *target = NULL;
+	struct ch32x_flash_bank *ch32x_info = NULL;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	ch32x_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = ch32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = target_read_u32(target, ch32_FLASH_OBR_B0, &optionbyte);
+	if (retval != ERROR_OK)
+		return retval;
+
+	uint16_t user_data = optionbyte >> ch32x_info->user_data_offset;
+
+	retval = target_read_u32(target, ch32_FLASH_WRPR_B0, &protection);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (optionbyte & (1 << OPT_ERROR))
+		command_print(CMD, "option byte complement error");
+
+	command_print(CMD, "option byte register = 0x%" PRIx32 "", optionbyte);
+	command_print(CMD, "write protection register = 0x%" PRIx32 "", protection);
+
+	command_print(CMD, "read protection: %s",
+				(optionbyte & (1 << OPT_READOUT)) ? "on" : "off");
+
+	/* user option bytes are offset depending on variant */
+	optionbyte >>= ch32x_info->option_offset;
+
+	command_print(CMD, "watchdog: %sware",
+				(optionbyte & (1 << OPT_RDWDGSW)) ? "soft" : "hard");
+
+	command_print(CMD, "stop mode: %sreset generated upon entry",
+				(optionbyte & (1 << OPT_RDRSTSTOP)) ? "no " : "");
+
+	command_print(CMD, "standby mode: %sreset generated upon entry",
+				(optionbyte & (1 << OPT_RDRSTSTDBY)) ? "no " : "");
+
+	if (ch32x_info->has_dual_banks)
+		command_print(CMD, "boot: bank %d", (optionbyte & (1 << OPT_BFB2)) ? 0 : 1);
+
+	command_print(CMD, "user data = 0x%02" PRIx16 "", user_data);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ch32x_handle_options_write_command)
+{
+	struct target *target = NULL;
+	struct ch32x_flash_bank *ch32x_info = NULL;
+	uint8_t optionbyte;
+	uint16_t useropt;
+
+	if (CMD_ARGC < 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	ch32x_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = ch32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = ch32x_read_options(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* start with current options */
+	optionbyte = ch32x_info->option_bytes.user;
+	useropt = ch32x_info->option_bytes.data;
+
+	/* skip over flash bank */
+	CMD_ARGC--;
+	CMD_ARGV++;
+
+	while (CMD_ARGC) {
+		if (strcmp("SWWDG", CMD_ARGV[0]) == 0)
+			optionbyte |= (1 << 0);
+		else if (strcmp("HWWDG", CMD_ARGV[0]) == 0)
+			optionbyte &= ~(1 << 0);
+		else if (strcmp("NORSTSTOP", CMD_ARGV[0]) == 0)
+			optionbyte |= (1 << 1);
+		else if (strcmp("RSTSTOP", CMD_ARGV[0]) == 0)
+			optionbyte &= ~(1 << 1);
+		else if (strcmp("NORSTSTNDBY", CMD_ARGV[0]) == 0)
+			optionbyte |= (1 << 2);
+		else if (strcmp("RSTSTNDBY", CMD_ARGV[0]) == 0)
+			optionbyte &= ~(1 << 2);
+		else if (strcmp("USEROPT", CMD_ARGV[0]) == 0) {
+			if (CMD_ARGC < 2)
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			COMMAND_PARSE_NUMBER(u16, CMD_ARGV[1], useropt);
+			CMD_ARGC--;
+			CMD_ARGV++;
+		}
+		else if (ch32x_info->has_dual_banks) {
+			if (strcmp("BOOT0", CMD_ARGV[0]) == 0)
+				optionbyte |= (1 << 3);
+			else if (strcmp("BOOT1", CMD_ARGV[0]) == 0)
+				optionbyte &= ~(1 << 3);
+			else
+				return ERROR_COMMAND_SYNTAX_ERROR;
+		} else
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		CMD_ARGC--;
+		CMD_ARGV++;
+	}
+
+	if (ch32x_erase_options(bank) != ERROR_OK) {
+		command_print(CMD, "ch32x failed to erase options");
+		return ERROR_OK;
+	}
+
+	ch32x_info->option_bytes.user = optionbyte;
+	ch32x_info->option_bytes.data = useropt;
+
+	if (ch32x_write_options(bank) != ERROR_OK) {
+		command_print(CMD, "ch32x failed to write options");
+		return ERROR_OK;
+	}
+
+	command_print(CMD, "ch32x write options complete.\n"
+				"INFO: %spower cycle is required "
+				"for the new settings to take effect.",
+				ch32x_info->can_load_options
+					? "'ch32f1x options_load' command or " : "");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ch32x_handle_options_load_command)
+{
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct ch32x_flash_bank *ch32x_info = bank->driver_priv;
+
+	if (!ch32x_info->can_load_options) {
+		LOG_ERROR("Command not applicable to ch32f1x devices - power cycle is "
+			"required instead.");
+		return ERROR_FAIL;
+	}
+
+	struct target *target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = ch32x_check_operation_supported(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* unlock option flash registers */
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_KEYR), KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_KEYR), KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* force re-load of option bytes - generates software reset */
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_CR), FLASH_OBL_LAUNCH);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int ch32x_mass_erase(struct flash_bank *bank)
+{
+	
+	struct target *target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* unlock option flash registers */
+	int retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_KEYR), KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_KEYR), KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* mass erase flash memory */
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_CR), FLASH_MER);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_CR),
+			FLASH_MER | FLASH_STRT);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = ch32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, ch32x_get_flash_reg(bank, ch32_FLASH_CR), FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ch32x_handle_mass_erase_command)
+{
+	int i;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = ch32x_mass_erase(bank);
+	if (retval == ERROR_OK) {
+		/* set all sectors as erased */
+		for (i = 0; i < bank->num_sectors; i++)
+			bank->sectors[i].is_erased = 1;
+
+		command_print(CMD, "ch32x mass erase complete");
+	} else
+		command_print(CMD, "ch32x mass erase failed");
+
+	return retval;
+}
+
+static const struct command_registration ch32x_exec_command_handlers[] = {
+	{
+		.name = "lock",
+		.handler = ch32x_handle_lock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Lock entire flash device.",
+	},
+	{
+		.name = "unlock",
+		.handler = ch32x_handle_unlock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Unlock entire protected flash device.",
+	},
+	{
+		.name = "mass_erase",
+		.handler = ch32x_handle_mass_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Erase entire flash device.",
+	},
+	{
+		.name = "options_read",
+		.handler = ch32x_handle_options_read_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Read and display device option bytes.",
+	},
+	{
+		.name = "options_write",
+		.handler = ch32x_handle_options_write_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id ('SWWDG'|'HWWDG') "
+			"('RSTSTNDBY'|'NORSTSTNDBY') "
+			"('RSTSTOP'|'NORSTSTOP') ('USEROPT' user_data)",
+		.help = "Replace bits in device option bytes.",
+	},
+	{
+		.name = "options_load",
+		.handler = ch32x_handle_options_load_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Force re-load of device option bytes.",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration ch32x_command_handlers[] = {
+	{
+		.name = "wch_arm",
+		.mode = COMMAND_ANY,
+		.help = "wch_arm flash command group",
+		.usage = "",
+		.chain = ch32x_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct flash_driver wch_arm_flash = {
+	.name = "wch_arm",
+	.commands = ch32x_command_handlers,
+	.flash_bank_command = ch32x_flash_bank_command,
+	.erase = ch32x_erase,
+	.protect = ch32x_protect,
+	.write = ch32x_write,
+	.read = default_flash_read,
+	.probe = ch32x_probe,
+	.auto_probe = ch32x_auto_probe,
+	.erase_check = default_flash_blank_check,
+	.protect_check = ch32x_protect_check,
+	.info = get_ch32x_info,
+	.free_driver_priv = default_flash_free_driver_priv,
+};
diff -Nur openocd/src/flash/nor/wchriscv.c openocd.new/src/flash/nor/wchriscv.c
--- openocd/src/flash/nor/wchriscv.c	1970-01-01 08:00:00.000000000 +0800
+++ openocd.new/src/flash/nor/wchriscv.c	2024-11-23 18:12:06.616366684 +0800
@@ -0,0 +1,233 @@
+/***************************************************************************
+ *   WCH RISC-V mcu :CH32V103X CH32V20X CH32V30X CH56X CH57X CH58X         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+extern int wlink_erase(void);
+extern unsigned char riscvchip;
+extern int wlink_reset();
+extern void wlink_getromram(uint32_t *rom,uint32_t *ram);
+extern int wlink_write(const uint8_t *buffer, uint32_t offset, uint32_t count);
+extern int noloadflag;
+extern int  wlink_flash_protect(bool stat);
+extern int wlnik_protect_check(void);
+extern int wlink_quitreset(void);
+extern int wlink_address;
+struct ch32vx_options
+{
+	uint8_t rdp;
+	uint8_t user;
+	uint16_t data;
+	uint32_t protection;
+};
+
+struct ch32vx_flash_bank
+{
+	struct ch32vx_options option_bytes;
+	int ppage_size;
+	int probed;
+
+	bool has_dual_banks;
+	bool can_load_options;
+	uint32_t register_base;
+	uint8_t default_rdp;
+	int user_data_offset;
+	int option_offset;
+	uint32_t user_bank_size;
+};
+
+FLASH_BANK_COMMAND_HANDLER(ch32vx_flash_bank_command)
+{
+	struct ch32vx_flash_bank *ch32vx_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	ch32vx_info = malloc(sizeof(struct ch32vx_flash_bank));
+
+	bank->driver_priv = ch32vx_info;
+	ch32vx_info->probed = 0;
+	ch32vx_info->has_dual_banks = false;
+	ch32vx_info->can_load_options = false;
+	ch32vx_info->user_bank_size = bank->size;
+
+	return ERROR_OK;
+}
+static int ch32x_protect(struct flash_bank *bank, int set, int first, int last)
+{	if(riscvchip==1)
+		wlink_quitreset();
+	if((riscvchip==1)||(riscvchip==5)||(riscvchip==6)||(riscvchip==9)){
+		int retval=wlink_flash_protect(set);
+		if(retval==ERROR_OK){
+				if(set)
+					LOG_INFO("Success to Enable Read-Protect");
+				else
+					LOG_INFO("Success to Disable Read-Protect");
+				return ERROR_OK;
+		}else{
+
+			LOG_ERROR("Operation Failed");
+			return ERROR_FAIL;
+		}
+				
+	}else{
+		LOG_ERROR("This chip do not support function");
+		return ERROR_FAIL;
+	}
+}
+
+static int ch32vx_erase(struct flash_bank *bank, int first, int last)
+{	
+	if((riscvchip==5)||(riscvchip==6)||(riscvchip==9)){
+			int retval=wlnik_protect_check();
+			if(retval==4){
+				LOG_ERROR("Read-Protect Status Currently Enabled");
+				return ERROR_FAIL;
+			}
+	}
+	if(noloadflag)
+		return ERROR_OK;
+	wlink_reset();
+	int ret = wlink_erase();
+	target_halt(bank->target);
+	if (ret)
+		return ERROR_OK;
+	else
+		return ERROR_FAIL;
+}
+
+static int ch32vx_write(struct flash_bank *bank, const uint8_t *buffer,
+						uint32_t offset, uint32_t count)
+{
+	if((riscvchip==5)||(riscvchip==6)||(riscvchip==9)){
+			int retval=wlnik_protect_check();
+			if(retval==4){
+				LOG_ERROR("Read-Protect Status Currently Enabled");
+				return ERROR_FAIL;
+			}
+	}
+	if(noloadflag)
+		return ERROR_OK;
+	
+	int ret = wlink_write(buffer, offset, count);
+	if((riscvchip==0x02)||(riscvchip==0x03))
+		 wlink_reset(); 
+	return ret;
+}
+
+static int ch32vx_get_device_id(struct flash_bank *bank, uint32_t *device_id)
+{
+	struct target *target = bank->target;
+	int retval = target_read_u32(target, 0x1ffff7e8, device_id);
+	if (retval != ERROR_OK)
+		return retval;
+	return ERROR_OK;
+}
+
+static int ch32vx_get_flash_size(struct flash_bank *bank, uint16_t *flash_size_in_kb)
+{
+
+	struct target *target = bank->target;
+	if((riscvchip==0x02)||(riscvchip==0x03)){
+		*flash_size_in_kb=448;
+		return ERROR_OK;
+	}
+	int retval = target_read_u16(target, 0x1ffff7e0, flash_size_in_kb);
+	if (retval != ERROR_OK)
+		return retval;
+	return ERROR_OK;
+}
+
+static int ch32vx_probe(struct flash_bank *bank)
+{
+	struct ch32vx_flash_bank *ch32vx_info = bank->driver_priv;
+	uint16_t delfault_max_flash_size=512;
+	uint16_t flash_size_in_kb;
+	uint32_t device_id;
+	uint32_t rom=0;
+	uint32_t ram=0;
+	int page_size;
+	uint32_t base_address = wlink_address;
+	uint32_t rid = 0;
+	ch32vx_info->probed = 0;
+	/* read ch32 device id register */
+	int retval = ch32vx_get_device_id(bank, &device_id);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_INFO("device id = 0x%08" PRIx32 "", device_id);
+	page_size = 1024;
+	ch32vx_info->ppage_size = 4;
+	/* get flash size from target. */
+	retval = ch32vx_get_flash_size(bank, &flash_size_in_kb);
+	if(flash_size_in_kb)
+		LOG_INFO("flash size = %dkbytes", flash_size_in_kb);
+	else
+		flash_size_in_kb=delfault_max_flash_size;
+	if((riscvchip==0x05)||(riscvchip==0x06)||(riscvchip==0x03))
+	{	
+		wlink_getromram(&rom,&ram);
+	if((rom != 0)&&(ram !=0))
+		LOG_INFO("ROM %d kbytes RAM %d kbytes" ,rom,ram);
+	}
+	// /* calculate numbers of pages */
+	int num_pages = flash_size_in_kb * 1024 / page_size;
+	bank->base = base_address;
+	bank->size = (num_pages * page_size);
+	bank->num_sectors = num_pages;
+	bank->sectors = alloc_block_array(0, page_size, num_pages);
+	ch32vx_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+static int ch32vx_auto_probe(struct flash_bank *bank)
+{
+
+	struct ch32vx_flash_bank *ch32vx_info = bank->driver_priv;
+	if (ch32vx_info->probed)
+		return ERROR_OK;
+	return ch32vx_probe(bank);
+}
+
+static const struct command_registration ch32vx_command_handlers[] = {
+	{
+		.name = "wch_riscv",
+		.mode = COMMAND_ANY,
+		.help = "wch_riscv flash command group",
+		.usage = "",
+
+	},
+	COMMAND_REGISTRATION_DONE};
+
+const struct flash_driver wch_riscv_flash = {
+	.name = "wch_riscv",
+	.commands = ch32vx_command_handlers,
+	.flash_bank_command = ch32vx_flash_bank_command,
+	.erase = ch32vx_erase,
+	.protect = ch32x_protect,
+	.write = ch32vx_write,
+	.read = default_flash_read,
+	.probe = ch32vx_probe,
+	.auto_probe = ch32vx_auto_probe,
+	.erase_check = default_flash_blank_check,
+	.free_driver_priv = default_flash_free_driver_priv,
+};
diff -Nur openocd/src/helper/options.c openocd.new/src/helper/options.c
--- openocd/src/helper/options.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/helper/options.c	2024-11-23 18:12:06.617366676 +0800
@@ -35,7 +35,7 @@
 #endif
 
 static int help_flag, version_flag;
-
+extern int noloadflag;
 static const struct option long_options[] = {
 	{"help",		no_argument,			&help_flag,		1},
 	{"version",		no_argument,			&version_flag,	1},
@@ -266,11 +266,12 @@
 {
 	int c;
 
+
 	while (1) {
 		/* getopt_long stores the option index here. */
 		int option_index = 0;
 
-		c = getopt_long(argc, argv, "hvd::l:f:s:c:", long_options, &option_index);
+		c = getopt_long(argc, argv, "hvd::l:f:s:c:x", long_options, &option_index);
 
 		/* Detect the end of the options. */
 		if (c == -1)
@@ -307,8 +308,11 @@
 					command_run_linef(cmd_ctx, "log_output %s", optarg);
 				break;
 			case 'c':		/* --command | -c */
-				if (optarg)
-				    add_config_command(optarg);
+				if (optarg)				
+				    add_config_command(optarg);								
+				break;
+			case 'x':              // for compatible	
+				noloadflag=1;
 				break;
 			default:  /* '?' */
 				/* getopt will emit an error message, all we have to do is bail. */
diff -Nur openocd/src/jtag/core.c openocd.new/src/jtag/core.c
--- openocd/src/jtag/core.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/jtag/core.c	2024-11-23 18:12:06.617366676 +0800
@@ -37,7 +37,7 @@
 
 /* ipdbg are utilities to debug IP-cores. It uses JTAG for transport. */
 #include "server/ipdbg.h"
-
+extern bool wchwlink;
 /** The number of JTAG queue flushes (for profiling and debugging purposes). */
 static unsigned int jtag_flush_queue_count;
 
@@ -1234,6 +1234,10 @@
 	 */
 	LOG_DEBUG("DR scan interrogation for IDCODE/BYPASS");
 	retval = jtag_examine_chain_execute(idcode_buffer, max_taps);
+	
+	if(wchwlink){
+		buf_set_u32(idcode_buffer, 0, 32, 0x00001);  //Default value,for reuse risc-v jtag debug
+	}
 	if (retval != ERROR_OK)
 		goto out;
 	if (!jtag_examine_chain_check(idcode_buffer, max_taps)) {
@@ -1411,7 +1415,7 @@
 		 */
 		uint64_t val = buf_get_u64(ir_test, chain_pos, tap->ir_length);
 		if ((val & tap->ir_capture_mask) != tap->ir_capture_value) {
-			LOG_ERROR("%s: IR capture error; saw 0x%0*" PRIx64 " not 0x%0*" PRIx32,
+			LOG_DEBUG("%s: IR capture error; saw 0x%0*" PRIx64 " not 0x%0*" PRIx32,
 				jtag_tap_name(tap),
 				(tap->ir_length + 7) / tap->ir_length, val,
 				(tap->ir_length + 7) / tap->ir_length, tap->ir_capture_value);
diff -Nur openocd/src/jtag/drivers/cmsis_dap.c openocd.new/src/jtag/drivers/cmsis_dap.c
--- openocd/src/jtag/drivers/cmsis_dap.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/jtag/drivers/cmsis_dap.c	2024-11-23 18:28:09.157941693 +0800
@@ -252,8 +252,9 @@
 
 static uint8_t output_pins = SWJ_PIN_SRST | SWJ_PIN_TRST;
 
-static struct cmsis_dap *cmsis_dap_handle;
+struct cmsis_dap *cmsis_dap_handle;
 
+extern void wlink_armversion(struct cmsis_dap *wdap);
 
 static int cmsis_dap_quit(void);
 
@@ -290,9 +291,11 @@
 	}
 
 	dap->backend = backend;
-
 	cmsis_dap_handle = dap;
 
+	wlink_armversion(dap);
+ 
+
 	return ERROR_OK;
 }
 
diff -Nur openocd/src/jtag/drivers/cmsis_dap_usb_bulk.c openocd.new/src/jtag/drivers/cmsis_dap_usb_bulk.c
--- openocd/src/jtag/drivers/cmsis_dap_usb_bulk.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/jtag/drivers/cmsis_dap_usb_bulk.c	2024-11-23 18:21:19.461772066 +0800
@@ -20,7 +20,7 @@
  *   spen@spen-soft.co.uk                                                  *
  ***************************************************************************/
 
-#ifdef HAVE_CONFIG_H
+#ifdef HAVE_CONFIG_H	
 #include "config.h"
 #endif
 
@@ -33,6 +33,8 @@
 #include "cmsis_dap.h"
 #include "libusb_helper.h"
 
+struct libusb_device_handle *wlink_dev_handle=NULL;
+
 enum {
 	CMSIS_DAP_TRANSFER_PENDING = 0,	/* must be 0, used in libusb_handle_events_completed */
 	CMSIS_DAP_TRANSFER_IDLE,
@@ -58,7 +60,7 @@
 };
 
 static int cmsis_dap_usb_interface = -1;
-
+extern bool wlink549;
 static void cmsis_dap_usb_close(struct cmsis_dap *dap);
 static int cmsis_dap_usb_alloc(struct cmsis_dap *dap, unsigned int pkt_sz);
 static void cmsis_dap_usb_free(struct cmsis_dap *dap);
@@ -440,6 +443,393 @@
 	}
 }
 
+
+
+
+
+extern uint8_t armchip;
+int timeout=300;
+// extern struct libusb_device_handle *wlink_dev_handle;
+extern unsigned  int  chip_type;
+static const uint32_t flash_code1[] = {
+	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+    0x4603B510, 0x04C00CD8, 0x444C4C7A, 0x20006020, 0x60204C79, 0x60604879, 0x60604879, 0x62604877,
+    0x62604877, 0x69C04620, 0x0004F000, 0xF245B940, 0x4C745055, 0x20066020, 0xF6406060, 0x60A070FF,
+    0xBD102000, 0x486C4601, 0xF0406900, 0x4A6A0080, 0x20006110, 0x48684770, 0xF0406900, 0x49660004,
+    0x46086108, 0xF0406900, 0x61080040, 0xF64AE003, 0x496420AA, 0x48606008, 0xF00068C0, 0x28000001,
+    0x485DD1F5, 0xF0206900, 0x495B0004, 0x20006108, 0xB5084770, 0x20004601, 0x48579000, 0xF0406900,
+    0x4A550002, 0x20016110, 0xBF009000, 0x61414852, 0xF0406900, 0x4A500040, 0xE0036110, 0x20AAF64A,
+    0x60104A50, 0x68C0484C, 0x0001F000, 0xD1F52800, 0x0000F89D, 0xB2C01E40, 0x28009000, 0x4846D1E6, 
+    0xF0206900, 0x4A440002, 0x20006110, 0xB5F0BD08, 0x460D4604, 0x46232608, 0x60086828, 0x40024842,
+    0x2200F442, 0x6102483C, 0x483BBF00, 0xF00068C0, 0x28000001, 0xF422D1F9, 0xBF002200, 0x6018C901,
+    0x6058C901, 0x6098C901, 0x60D8C901, 0x2280F442, 0x61024831, 0xBF003310, 0x68C0482F, 0x0001F000,
+    0xD1F92800, 0xB2C01E70, 0xD1E71E06, 0x2280F422, 0x007FF024, 0x61784F28, 0x0240F042, 0x61024638,
+    0x0240F022, 0x4824BF00, 0xF00068C0, 0x28000001, 0x4821D1F9, 0xF00068C0, 0xB1600014, 0x68C0481E,
+    0x0014F040, 0x60F84F1C, 0x20FFF240, 0x46384002, 0x20016102, 0x2000BDF0, 0xE92DE7FC, 0x460641F8,
+    0x4615460F, 0x0800F04F, 0xF1079600, 0xF3C0007F, 0x481118C7, 0xF4446904, 0x61043480, 0x4622BF00,
+    0x98004629, 0xFF93F7FF, 0x2001B110, 0x81F8E8BD, 0x30809800, 0x35809000, 0x0001F1A8, 0xF1B0B2C0,  
+    0xD1EC0800, 0x20FFF240, 0x48034004, 0x20006104, 0x0000E7EC, 0x00000004, 0x40022000, 0x45670123,
+    0xCDEF89AB, 0x40003000, 0x000102FF, 0x00000000, 0x00000000, 
+};
+
+uint32_t program_code1[] = {
+	0x20000021, // Init
+	0x20000065, // UnInit
+	0x20000077, // EraseChip
+	0x200000B3, // EraseSector
+	0x200001BB, // ProgramPage
+	0x20000001,
+	0x20000C00,
+	0x20001000,
+	0x20000400, // mem buffer location
+	0x20000000, // location to write prog_blob in target RAM
+	(uint32_t)sizeof(flash_code1),
+};
+
+static const uint32_t flash_code2[] = {
+	0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,
+	0x4603B510, 0x04C00CD8, 0x444C4C55, 0x20006020, 0x60204C54, 0x60604854, 0x60604854, 0x62604852,
+	0x62604852, 0x69C04620, 0x0004F000, 0xF245B940, 0x4C4F5055, 0x20066020, 0xF6406060, 0x60A070FF,
+	0xBD102000, 0x48474601, 0xF0406900, 0x4A450080, 0x20006110, 0x48434770, 0xF0406900, 0x49410004,
+	0x46086108, 0xF0406900, 0x61080040, 0xF64AE003, 0x493F20AA, 0x483B6008, 0xF00068C0, 0x28000001,
+	0x4838D1F5, 0xF0206900, 0x49360004, 0x20006108, 0x46014770, 0x69004833, 0x0002F040, 0x61104A31,
+	0x61414610, 0xF0406900, 0x61100040, 0xF64AE003, 0x4A2F20AA, 0x482B6010, 0xF00068C0, 0x28000001,
+	0x4828D1F5, 0xF0206900, 0x4A260002, 0x20006110, 0xB5704770, 0x25004603, 0xF0232440, 0xF10103FF,
+	0xF3C000FF, 0x481F2507, 0xF4406900, 0x4E1D3080, 0xBF006130, 0xE00C2440, 0x60186810, 0x1D121D1B,
+	0xB2C41E60, 0x4817BF00, 0xF00068C0, 0x28000002, 0x2C00D1F9, 0x4813D1F0, 0xF4406900, 0x4E111000,
+	0xBF006130, 0x68C0480F, 0x0001F000, 0xD1F92800, 0xB2C01E68, 0xD1DD0005, 0x6900480A, 0x3080F420,
+	0x61304E08, 0x68C04630, 0x0010F000, 0x4630B130, 0xF04068C0, 0x60F00010, 0xBD702001, 0xE7FC2000,
+	0x00000004, 0x40022000, 0x45670123, 0xCDEF89AB, 0x40003000, 0x00000000, 0x00000000};
+
+uint32_t program_code2[] = {
+	0x20000021, // Init
+	0x20000065, // UnInit
+	0x20000077, // EraseChip
+	0x200000B3, // EraseSector
+	0x200000F3, // ProgramPage
+
+	// BKPT : start of blob + 1
+	// RSB  : address to access global/static data
+	// RSP  : stack pointer
+
+	0x20000001,
+	0x20000C00,
+	0x20001000,
+	0x20000400,			 // mem buffer location
+	0x20000000,			 // location to write prog_blob in target RAM
+	sizeof(flash_code2), // prog_blob size
+};
+
+void wlink_sendchip(uint8_t config)
+{
+	int transferred = 0;
+	uint16_t rom=0;
+	uint16_t ram=0;
+	uint8_t buffer_code[5] = { 0x81, 0x0c, 0x02, 0x08, 0x01};
+	uint8_t buffer_rcode[20];
+	if (armchip == 1)
+		buffer_code[3] = 0x04;
+	if (armchip == 2)
+		buffer_code[3] = 0x08;
+
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,buffer_code,sizeof(buffer_code),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,4,&transferred,timeout);
+	buffer_code[1]=0x11;
+	buffer_code[2]=0x01;
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,buffer_code,4,&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);	
+	chip_type=((unsigned int)buffer_rcode[19]) + (((unsigned int)buffer_rcode[18])<<8) + (((unsigned int)buffer_rcode[17])<<16) +(((unsigned int) buffer_rcode[16])<<24);	
+	chip_type = chip_type & 0xffffff0f;
+	bool type_A=false;
+	bool type_B=false;
+	if(chip_type==0x20700408 ||chip_type==0x20300404 ||chip_type==0x20310404 )
+		type_A=true;
+	if(chip_type==0x2080040c  || chip_type==0x2081040c)
+		type_B=true;
+	switch(config){
+		case 0:
+           if(type_A){
+				 rom=192;
+                 ram=128;
+			 }
+			else if(type_B){
+				 rom=128;
+                 ram=64;
+			}else{
+ 				 rom=0;
+                 ram=0;
+			}
+			break;
+		case 1:
+			if(type_A){
+				 rom=224;
+                 ram=96;
+			 }
+			else if(type_B){
+				 rom=144;
+                 ram=48;
+			}else{
+ 				 rom=0;
+                 ram=0;
+			}
+			break;
+		case 2:
+			if(type_A){
+				 rom=256;
+                 ram=64;
+			 }
+			else if(type_B){
+				 rom=160;
+                 ram=32;
+			}else{
+ 				 rom=0;
+                 ram=0;
+			}
+			break;
+		case 3:
+           if(type_A){
+				 rom=288;
+                 ram=32;
+			 }
+			else if(type_B){
+				 rom=160;
+                 ram=32;
+			}else{
+ 				 rom=0;
+                 ram=0;
+			}
+			break;
+		default:
+				 rom=0;
+                 ram=0;
+			  break;
+	}
+	if((rom!=0) && (ram!=0))
+		LOG_INFO("ROM %d kbytes RAM %d kbytes" ,rom,ram);
+
+	
+}
+void wlink_armversion(struct cmsis_dap *dap){
+	
+	int transferred = 0;
+	unsigned char txbuf[4]={0x81,0x0d,0x1,0x1};
+	unsigned char rxbuf[20];
+	int len=7;
+	char * wlink_name=NULL;
+	wlink_dev_handle=dap->bdata->dev_handle;
+	libusb_bulk_transfer(dap->bdata->dev_handle, 0x02,txbuf,sizeof(txbuf),&transferred,timeout);
+	usleep(1000);
+	libusb_bulk_transfer(dap->bdata->dev_handle, 0x83,rxbuf,len,&transferred,timeout);
+	switch (rxbuf[5])
+		{
+		case 1:
+			wlink_name="WCH-Link-CH549  mod:ARM";
+			wlink549=true;
+			break;
+		case 2:
+			wlink_name="WCH-LinkE-CH32V307  mod:ARM";
+			break;
+		case 3:
+			wlink_name="WCH-LinkS-CH32V203  mod:ARM";
+			break;
+		case 4:
+			wlink_name="WCH-LinkB  mod:ARM";
+			break;
+		default:
+			LOG_ERROR("unknow WCH-LINK ");	
+			break;
+		}
+	LOG_INFO("%s version %d.%d ",wlink_name, rxbuf[3], rxbuf[4]);
+}
+int wlink_armcheckprotect(void)
+{
+	int transferred = 0;
+
+	uint8_t buffer_clk[] = { 0x81, 0x0c, 0x02, 0x08, 0x01};
+	uint8_t buffer_code[] = {0x81, 0x06, 0x01, 0x01};
+	uint8_t buffer_rcode[4];
+	if (armchip == 1)
+		buffer_clk[3] = 0x04;
+	if (armchip == 2)
+		buffer_clk[3] = 0x08;	
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,buffer_clk,sizeof(buffer_code),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+	// hid_write(wlink_dev_handle, buffer_clk, 65);
+	// hid_read_timeout(wlink_dev_handle, buffer_rcode, 65, beytime);
+	if ((*(buffer_rcode + 0) == 0x82) && (*(buffer_rcode + 1) == 0x0c) && (*(buffer_rcode + 2) == 0x01)  && (*(buffer_rcode + 3 )== 0x01))
+	{
+		libusb_bulk_transfer(wlink_dev_handle, 0x02,buffer_code,sizeof(buffer_code),&transferred,timeout);
+		libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+		// hid_write(wlink_dev_handle, buffer_code, 65);
+		// hid_read(wlink_dev_handle, buffer_rcode, 65);
+		if (buffer_rcode[3] == 1)
+		{
+			LOG_ERROR(" Please Disable R-Protect");
+			return ERROR_FAIL;
+		}
+		return ERROR_OK;
+	}
+}
+int wlink_armerase(void)
+{
+	uint8_t buffer_code[] = { 0x81, 0x02, 0x01, 0x05};
+	int transferred=0;
+	uint8_t buffer_rcode[4];
+	uint32_t *comprogram = NULL;
+	uint32_t *comflash = NULL;
+	if (armchip == 1)
+	{
+		comprogram = program_code1;
+		comflash = flash_code1;
+	}
+
+	if (armchip == 2)
+	{
+		comprogram = program_code2;
+		comflash = flash_code2;
+	}
+	uint8_t i = 0;
+	uint8_t *flashcode = (uint8_t *)comflash;
+
+	int h = *(comprogram + 10);
+
+	uint8_t txbuf[64] = {0x0};
+	int loopcount = 0;
+	// hid_write(wlink_dev_handle, buffer_code, 65);
+	// hid_read(wlink_dev_handle, buffer_rcode, 65);
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,buffer_code,sizeof(buffer_code),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+	for (int f = 0; f <= 43; f++)
+	{
+		txbuf[f] = *(((uint8_t *)comprogram) + f);
+	}
+	// hid_write(wlink_dev_handle, txbuf, 65);
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,txbuf,44,&transferred,timeout);
+	while (h > 0)
+	{
+		for (int j = 0; j < 64; j++)
+		{
+			txbuf[j] = *((uint8_t *)comflash + (j) + loopcount);
+		}
+		// hid_write(wlink_dev_handle, txbuf, 65);
+		libusb_bulk_transfer(wlink_dev_handle, 0x02,txbuf,sizeof(txbuf),&transferred,timeout);
+		h -= 64;
+		loopcount += 64;
+	}
+	uint8_t buffer_erase[] = { 0x81, 0x02, 0x01, 0x01};
+	// int retval = hid_write(wlink_dev_handle, buffer_erase, 65);
+	// hid_read(wlink_dev_handle, buffer_rcode, 65);
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,buffer_erase,sizeof(buffer_erase),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+	if ((*(buffer_rcode + 0) == 0x82) && (*(buffer_rcode + 1) == 0x02) && (*(buffer_rcode + 2) == 0x01) && (*(buffer_rcode + 3) == 0x01))
+	{
+		return ERROR_OK;
+	}
+	LOG_ERROR(" ERASE FAILED");
+	return ERROR_FAIL;
+}
+int wlink_armwrite(const uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	int transferred = 0;
+	uint8_t *addr = &offset;
+	uint8_t flash_write[] = {0x81, 0x02, 0x01, 0x02};
+	uint8_t buffer_rcode[4];
+	uint8_t i = 0;
+	uint8_t txbuf[64] = {0};
+	int loopcount = 0;
+	int mount = count;
+	uint32_t modflag = count % 256;
+	uint8_t *buffer1 = malloc(count + 256 - modflag);
+	memcpy(buffer1, buffer, count);
+	if (modflag)
+	{
+		count = count + 256 - modflag;
+		memset((buffer1 + mount), 0xff, (256 - modflag));
+	}
+
+	uint8_t address[] = { 0x81, 0x01, 0x08, *(addr + 3), *(addr + 2), *(addr + 1), *addr,(count >> 24) & 0xff, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff};
+	// hid_write(wlink_dev_handle, address, 65); 
+	// hid_read_timeout(wlink_dev_handle, buffer_rcode, 65, beytime);
+	// hid_write(wlink_dev_handle, countsize, 65);
+	// hid_read_timeout(wlink_dev_handle, buffer_rcode, 65, beytime); 
+	// hid_write(wlink_dev_handle, flash_write, 65); 
+	// int retval = hid_read_timeout(wlink_dev_handle, buffer_rcode, 65, beytime);
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,address,sizeof(address),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+	// libusb_bulk_transfer(wlink_dev_handle, 0x02,countsize,sizeof(countsize),&transferred,timeout);
+	// libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x02,flash_write,sizeof(flash_write),&transferred,timeout);
+	libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+	while (count > 0)
+	{
+		for (int j = 0; j < 64; j++)
+		{
+			txbuf[j] = *(buffer1 + j  + loopcount);
+		}
+		// hid_write(wlink_dev_handle, txbuf, 65);
+		libusb_bulk_transfer(wlink_dev_handle, 0x02,txbuf,sizeof(txbuf),&transferred,timeout);
+		count -= 64;
+		loopcount += 64;
+		if (++i % 2 == 0)
+		{
+			// hid_read(wlink_dev_handle, buffer_rcode, 65);
+			libusb_bulk_transfer(wlink_dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+			if ((*(buffer_rcode + 0) == 0x41) && (*(buffer_rcode + 1) == 0x01) && (*(buffer_rcode + 2) == 0x01) && ((*(buffer_rcode + 3) == 0x02) || (*(buffer_rcode + 3) == 0x04)))
+			{
+			}
+			else
+			{
+				LOG_ERROR(" PROGRAM FAILED");
+				return ERROR_FAIL;
+			}
+		}
+	}
+	return ERROR_OK;
+}
+
+void wlink_armquitreset(struct cmsis_dap *dap)
+{
+	int transferred =0;
+	uint8_t resetbuffer[] = {0x81, 0x0b, 0x01, 0x00};
+	uint8_t buffer_rcode[4];
+	// hid_write(wlink_dev_handle, resetbuffer, 65);
+	// hid_read(wlink_dev_handle, buffer_rcode, 65);
+    libusb_bulk_transfer(dap->bdata->dev_handle, 0x02,resetbuffer,sizeof(resetbuffer),&transferred,timeout);
+	int ret=libusb_bulk_transfer(dap->bdata->dev_handle, 0x83,buffer_rcode,sizeof(buffer_rcode),&transferred,timeout);
+
+
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 static int cmsis_dap_usb_read(struct cmsis_dap *dap, int transfer_timeout_ms,
 							  struct timeval *wait_timeout)
 {
diff -Nur openocd/src/jtag/drivers/cmsis_dap_usb_hid.c openocd.new/src/jtag/drivers/cmsis_dap_usb_hid.c
--- openocd/src/jtag/drivers/cmsis_dap_usb_hid.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/jtag/drivers/cmsis_dap_usb_hid.c	2024-11-23 18:12:06.618366668 +0800
@@ -97,7 +97,7 @@
 			if (!cur_dev->product_string) {
 				LOG_DEBUG("Cannot read product string of device 0x%x:0x%x",
 					  cur_dev->vendor_id, cur_dev->product_id);
-			} else if (wcsstr(cur_dev->product_string, L"CMSIS-DAP")) {
+			} else if (wcsstr(cur_dev->product_string, L"CMSIS-DAP")||wcsstr(cur_dev->product_string, L"WCH-Link")) {
 				/* if the user hasn't specified VID:PID *and*
 				 * product string contains "CMSIS-DAP", pick it
 				 */
diff -Nur openocd/src/jtag/drivers/Makefile.am openocd.new/src/jtag/drivers/Makefile.am
--- openocd/src/jtag/drivers/Makefile.am	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/jtag/drivers/Makefile.am	2024-11-23 18:12:06.617366676 +0800
@@ -7,7 +7,7 @@
 	$(DRIVERFILES) \
 	$(DRIVERHEADERS)
 
-%C%_libocdjtagdrivers_la_CPPFLAGS = $(AM_CPPFLAGS)
+%C%_libocdjtagdrivers_la_CPPFLAGS = $(AM_CPPFLAGS) -Wno-incompatible-pointer-types
 
 ULINK_FIRMWARE = %D%/OpenULINK
 ANGIE_FILES = %D%/angie
@@ -204,6 +204,10 @@
 if AM335XGPIO
 DRIVERFILES += %D%/am335xgpio.c
 endif
+if WLINK
+DRIVERFILES += %D%/wlink.c
+endif
+
 
 DRIVERHEADERS = \
 	%D%/bitbang.h \
diff -Nur openocd/src/jtag/drivers/wlink.c openocd.new/src/jtag/drivers/wlink.c
--- openocd/src/jtag/drivers/wlink.c	1970-01-01 08:00:00.000000000 +0800
+++ openocd.new/src/jtag/drivers/wlink.c	2024-11-23 18:12:06.618366668 +0800
@@ -0,0 +1,1949 @@
+/*
+ * WCH_LINLK port debug driver for WCH RISC-V mcu :
+   CH32V103X;CH32V20X,CH32V30X;CH56X;CH57X;CH58X
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+ 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <jtag/adapter.h>
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#include "cmsis_dap.h"
+#ifdef _WIN32
+#include <windows.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+#include "hidapi.h"
+typedef int(__stdcall *pCH375OpenDevice)(unsigned long iIndex);
+typedef void(__stdcall *pCH375CloseDevice)(unsigned long iIndex);
+typedef unsigned long(__stdcall *pCH375SetTimeout)(unsigned long iIndex,
+												   unsigned long iWriteTimeout,
+												   unsigned long iReadTimeout);
+typedef unsigned long(__stdcall *pCH375ReadEndP)(unsigned long iIndex,
+												 unsigned long iPipeNum,
+												 void *iBuffer,
+												 unsigned long *ioLength);
+typedef unsigned long(__stdcall *pCH375WriteEndP)(unsigned long iIndex,
+												  unsigned long iPipeNum,
+												  void *iBuffer,
+												  unsigned long *ioLength);
+HMODULE hModule = 0;
+BOOL gOpen = FALSE;
+ULONG gIndex = 0;
+pCH375OpenDevice pOpenDev;
+pCH375CloseDevice pCloseDev;
+pCH375SetTimeout pSetTimeout;
+pCH375ReadEndP pReadData;
+pCH375WriteEndP pWriteData;
+#else
+#include "libusb_helper.h"
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <stdint.h>
+int gIndex = 0;
+static const uint16_t wlink_vids[] = {0x1a86, 0};
+static const uint16_t wlink_pids[] = {0x8010, 0};
+struct jtag_libusb_device_handle *wfd = NULL;
+int pWriteData(int dev, int endpoint, unsigned char *buf, unsigned long *length)
+{
+	int ret,pr;
+	length = (int *)length;
+	ret =jtag_libusb_bulk_write(wfd, endpoint, buf, *length, 3000,&pr);
+	if(ret==ERROR_OK)
+		 return 1;
+	else
+		 return ret;
+}
+int pReadData(int dev, int endpoint, unsigned char *buf, unsigned long *length)
+{
+	int ret,pr;
+	length = (int *)length;
+	if (endpoint == 1)
+	{
+		ret=jtag_libusb_bulk_read(wfd, 0x81, buf, *length, 3000,&pr);
+	}
+	else
+	{
+		ret=jtag_libusb_bulk_read(wfd, 0x82, buf, *length, 3000,&pr);
+	}
+	if(ret==ERROR_OK)
+		 return 1;
+	else
+		 return ret;
+}
+#endif
+int wlink_address=0;
+bool wlink549 =false;
+bool pageerase=false;
+unsigned char riscvchip;
+unsigned  int  chip_type;
+unsigned long chipiaddr;
+unsigned long pagesize;
+unsigned long ramaddr;
+bool wchwlink;
+int noloadflag=0; 
+uint8_t flash_op103[ ] ={
+    0x93, 0x77, 0x15, 0x00, 0x41, 0x11, 0x99, 0xCF, 0xB7, 0x06, 0x67, 0x45, 0xB7, 0x27, 0x02, 0x40, 
+    0x93, 0x86, 0x36, 0x12, 0x37, 0x97, 0xEF, 0xCD, 0xD4, 0xC3, 0x13, 0x07, 0xB7, 0x9A, 0xD8, 0xC3, 
+    0xD4, 0xD3, 0xD8, 0xD3, 0x93, 0x77, 0x25, 0x00, 0x9D, 0xC7, 0xB7, 0x27, 0x02, 0x40, 0x98, 0x4B, 
+    0xAD, 0x66, 0x37, 0x38, 0x00, 0x40, 0x13, 0x67, 0x47, 0x00, 0x98, 0xCB, 0x98, 0x4B, 0x93, 0x86, 
+    0xA6, 0xAA, 0x13, 0x67, 0x07, 0x04, 0x98, 0xCB, 0xD8, 0x47, 0x05, 0x8B, 0x63, 0x1F, 0x07, 0x10, 
+    0x98, 0x4B, 0x6D, 0x9B, 0x98, 0xCB, 0x93, 0x77, 0x45, 0x00, 0xA9, 0xCB, 0x93, 0x07, 0xF6, 0x07, 
+    0x9D, 0x83, 0x2E, 0xC0, 0x2D, 0x68, 0x81, 0x76, 0x3E, 0xC4, 0xB7, 0x08, 0x02, 0x00, 0xB7, 0x27, 
+    0x02, 0x40, 0x37, 0x33, 0x00, 0x40, 0x13, 0x08, 0xA8, 0xAA, 0xFD, 0x16, 0x98, 0x4B, 0x33, 0x67,   
+    0x17, 0x01, 0x98, 0xCB, 0x02, 0x47, 0xD8, 0xCB, 0x98, 0x4B, 0x13, 0x67, 0x07, 0x04, 0x98, 0xCB, 
+    0xD8, 0x47, 0x05, 0x8B, 0x71, 0xEF, 0x98, 0x4B, 0x75, 0x8F, 0x98, 0xCB, 0x02, 0x47, 0x13, 0x07, 
+    0x07, 0x08, 0x3A, 0xC0, 0x22, 0x47, 0x7D, 0x17, 0x3A, 0xC4, 0x69, 0xFB, 0x93, 0x77, 0x85, 0x00, 
+    0xED, 0xC3, 0x93, 0x07, 0xF6, 0x07, 0x2E, 0xC0, 0x9D, 0x83, 0x37, 0x27, 0x02, 0x40, 0x3E, 0xC4, 
+    0x1C, 0x4B, 0xC1, 0x66, 0x37, 0x08, 0x08, 0x00, 0xD5, 0x8F, 0x1C, 0xCB, 0xA1, 0x48, 0x37, 0x17, 
+    0x00, 0x20, 0xB7, 0x27, 0x02, 0x40, 0x37, 0x03, 0x04, 0x00, 0x94, 0x4B, 0xB3, 0xE6, 0x06, 0x01, 
+    0x94, 0xCB, 0xD4, 0x47, 0x85, 0x8A, 0xF5, 0xFE, 0x82, 0x46, 0x3A, 0x8E, 0x36, 0xC2, 0x46, 0xC6, 
+    0x92, 0x46, 0x83, 0x2E, 0x07, 0x00, 0x41, 0x07, 0x23, 0xA0, 0xD6, 0x01, 0x92, 0x46, 0x83, 0x2E,    
+    0x47, 0xFF, 0x23, 0xA2, 0xD6, 0x01, 0x92, 0x46, 0x83, 0x2E, 0x87, 0xFF, 0x23, 0xA4, 0xD6, 0x01, 
+    0x92, 0x46, 0x03, 0x2E, 0xCE, 0x00, 0x23, 0xA6, 0xC6, 0x01, 0x94, 0x4B, 0xB3, 0xE6, 0x66, 0x00, 
+    0x94, 0xCB, 0xD4, 0x47, 0x85, 0x8A, 0xF5, 0xFE, 0x92, 0x46, 0x3A, 0x8E, 0xC1, 0x06, 0x36, 0xC2, 
+    0xB2, 0x46, 0xFD, 0x16, 0x36, 0xC6, 0xCD, 0xFE, 0x82, 0x46, 0xD4, 0xCB, 0x94, 0x4B, 0x93, 0xE6, 
+    0x06, 0x04, 0x94, 0xCB, 0xD4, 0x47, 0x85, 0x8A, 0xF5, 0xFE, 0xD4, 0x47, 0xD1, 0x8A, 0x85, 0xC6, 
+    0xD8, 0x47, 0xB7, 0x06, 0xF3, 0xFF, 0xFD, 0x16, 0x13, 0x67, 0x47, 0x01, 0xD8, 0xC7, 0x98, 0x4B, 
+    0x21, 0x45, 0x75, 0x8F, 0x98, 0xCB, 0x41, 0x01, 0x02, 0x90, 0x23, 0x20, 0xD8, 0x00, 0xE9, 0xBD, 
+    0x23, 0x20, 0x03, 0x01, 0x31, 0xBF, 0x82, 0x46, 0x93, 0x86, 0x06, 0x08, 0x36, 0xC0, 0xA2, 0x46,   
+    0xFD, 0x16, 0x36, 0xC4, 0xB9, 0xFA, 0x98, 0x4B, 0xB7, 0x06, 0xF3, 0xFF, 0xFD, 0x16, 0x75, 0x8F, 
+    0x98, 0xCB, 0x41, 0x89, 0x15, 0xC9, 0x2E, 0xC0, 0x0D, 0x06, 0x02, 0xC4, 0x09, 0x82, 0x32, 0xC6, 
+    0xB7, 0x17, 0x00, 0x20, 0x98, 0x43, 0x13, 0x86, 0x47, 0x00, 0xA2, 0x47, 0x82, 0x46, 0x8A, 0x07, 
+    0xB6, 0x97, 0x9C, 0x43, 0x63, 0x1C, 0xF7, 0x00, 0xA2, 0x47, 0x85, 0x07, 0x3E, 0xC4, 0xA2, 0x46, 
+    0x32, 0x47, 0xB2, 0x87, 0xE3, 0xE0, 0xE6, 0xFE, 0x01, 0x45, 0x71, 0xBF, 0x41, 0x45, 0x61, 0xBF, 
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+uint8_t flash_op569[ ] ={
+0x79,0x71,0x22,0xd4,0x26,0xd2,0x5a,0xc8,0x06,0xd6,0x4a,0xd0,0x4e,0xce,0x52,0xcc,
+0x56,0xca,0x5e,0xc6,0x93,0x77,0x15,0x00,0x2a,0x84,0x2e,0x8b,0xb2,0x84,0x9d,0xe7,
+0x93,0x77,0x24,0x00,0x99,0xc7,0xb7,0x85,0x07,0x00,0x01,0x45,0x59,0x22,0x89,0x47,
+0x15,0xe1,0x93,0x77,0x44,0x00,0x91,0xc7,0x85,0x65,0x5a,0x85,0x9d,0x2a,0x91,0x47,
+0x11,0xe9,0x93,0x77,0x84,0x01,0x9d,0xe3,0x81,0x47,0x29,0xa0,0x01,0x45,0xc5,0x26,
+0x85,0x47,0x79,0xd5,0xb2,0x50,0x22,0x54,0x92,0x54,0x02,0x59,0xf2,0x49,0x62,0x4a,
+0xd2,0x4a,0x42,0x4b,0xb2,0x4b,0x3e,0x85,0x45,0x61,0x02,0x90,0x93,0x84,0xf4,0x0f,
+0x93,0x7b,0x84,0x00,0xa1,0x80,0x01,0x49,0xb7,0x1a,0x00,0x20,0x41,0x88,0x93,0x19,
+0x89,0x00,0x33,0x8a,0x69,0x01,0x63,0x9e,0x0b,0x00,0x0d,0xc4,0x13,0x06,0x00,0x10,
+0xb3,0x85,0x59,0x01,0x52,0x85,0x01,0x2e,0x13,0x75,0xf5,0x0f,0x01,0xcd,0xc1,0x47,
+0x55,0xbf,0x13,0x06,0x00,0x10,0xb3,0x85,0x59,0x01,0x52,0x85,0xed,0x22,0x71,0xdd,
+0xa1,0x47,0x4d,0xb7,0x05,0x09,0xe3,0x94,0x24,0xfd,0x79,0xb7,0x37,0x17,0x00,0x40,
+0x83,0x47,0xa7,0x01,0xe2,0x07,0xe1,0x87,0xe3,0xcc,0x07,0xfe,0x23,0x0d,0x07,0x00,
+0x82,0x80,0x37,0x17,0x00,0x40,0x83,0x47,0xa7,0x01,0xe2,0x07,0xe1,0x87,0xe3,0xcc,
+0x07,0xfe,0x23,0x0c,0xa7,0x00,0x82,0x80,0x37,0x17,0x00,0x40,0x83,0x47,0xa7,0x01,
+0xe2,0x07,0xe1,0x87,0xe3,0xcc,0x07,0xfe,0x03,0x45,0x87,0x01,0x82,0x80,0x41,0x11,
+0x22,0xc4,0x2a,0x84,0x41,0x81,0x13,0x75,0xf5,0x0f,0x06,0xc6,0xd9,0x37,0x13,0x55,
+0x84,0x00,0x13,0x75,0xf5,0x0f,0x75,0x3f,0x13,0x75,0xf4,0x0f,0x22,0x44,0xb2,0x40,
+0x41,0x01,0x45,0xbf,0x01,0x11,0x22,0xcc,0x26,0xca,0x06,0xce,0x37,0x14,0x00,0x40,
+0x2a,0xc6,0x23,0x0d,0x04,0x00,0x9d,0x44,0x23,0x0d,0x94,0x00,0x99,0x47,0x23,0x0c,
+0xf4,0x00,0xad,0x3f,0x23,0x0d,0x04,0x00,0x23,0x0d,0x94,0x00,0x32,0x45,0x23,0x0c,
+0xa4,0x00,0xf2,0x40,0x62,0x44,0xd2,0x44,0x05,0x61,0x82,0x80,0x79,0x71,0x4a,0xd0,
+0x37,0x19,0x00,0x40,0x22,0xd4,0x26,0xd2,0x4e,0xce,0x52,0xcc,0x06,0xd6,0x37,0x04,
+0x28,0x00,0xa9,0x37,0x93,0x04,0xa9,0x01,0x1d,0x4a,0x95,0x49,0x23,0x80,0x04,0x00,
+0x23,0x80,0x44,0x01,0x23,0x0c,0x39,0x01,0x85,0x37,0xb9,0x3f,0x2a,0xc6,0x3d,0x37,
+0x32,0x45,0x05,0x89,0x09,0xcd,0x7d,0x14,0x75,0xf0,0x13,0x05,0xf0,0x0f,0xb2,0x50,
+0x22,0x54,0x92,0x54,0x02,0x59,0xf2,0x49,0x62,0x4a,0x45,0x61,0x82,0x80,0x01,0x45,
+0xfd,0xb7,0xb7,0x16,0x00,0x40,0x03,0xc7,0x46,0x00,0x41,0x8b,0x71,0xeb,0x05,0x67,
+0x01,0x11,0x7d,0x17,0x22,0xcc,0x33,0x84,0xe5,0x00,0x69,0x8f,0x26,0xca,0x3a,0x94,
+0xfd,0x74,0x65,0x8c,0x06,0xce,0xe9,0x8c,0x4a,0xc8,0x4e,0xc6,0x37,0x06,0x08,0x00,
+0xaa,0x87,0x13,0x05,0xe0,0x0f,0x63,0xf7,0xc4,0x06,0x33,0x07,0x94,0x00,0x13,0x05,
+0xa0,0x0f,0x63,0x61,0xe6,0x06,0x13,0x07,0x70,0x05,0x23,0x80,0xe6,0x00,0x13,0x07,
+0x80,0xfa,0x23,0x80,0xe6,0x00,0x03,0xc7,0x46,0x00,0x3d,0x65,0xe9,0x8f,0x13,0x67,
+0xc7,0x08,0x23,0x82,0xe6,0x00,0x91,0xe7,0xb7,0x09,0x07,0x00,0x41,0x69,0x63,0xe2,
+0x34,0x05,0xa2,0x94,0x05,0x69,0xb3,0x89,0x84,0x40,0x63,0x79,0x24,0x05,0x01,0x45,
+0x37,0x17,0x00,0x40,0x93,0x07,0x70,0x05,0x23,0x00,0xf7,0x00,0x93,0x07,0x80,0xfa,
+0x23,0x00,0xf7,0x00,0x83,0x47,0x47,0x00,0x93,0xf7,0x37,0x07,0x93,0xe7,0x07,0x08,
+0x23,0x02,0xf7,0x00,0xf2,0x40,0x62,0x44,0xd2,0x44,0x42,0x49,0xb2,0x49,0x05,0x61,
+0x82,0x80,0xe3,0x60,0x24,0xfd,0x13,0x05,0x80,0x0d,0x6d,0x3d,0x26,0x85,0x41,0x3d,
+0xf5,0x35,0x5d,0xfd,0xca,0x94,0x33,0x04,0x24,0x41,0x55,0xb7,0x13,0x05,0x00,0x02,
+0x55,0x35,0x4e,0x85,0xad,0x3d,0xd9,0x3d,0x45,0xf5,0x33,0x04,0x24,0x41,0x61,0xbf,
+0x13,0x05,0xb0,0x0f,0x82,0x80,0x01,0x11,0x22,0xcc,0x37,0x04,0x00,0x10,0x71,0x14,
+0x69,0x8c,0x21,0x65,0x2a,0x94,0x06,0xce,0x26,0xca,0x4a,0xc8,0x4e,0xc6,0x37,0x07,
+0x08,0x00,0x13,0x05,0xe0,0x0f,0x63,0x71,0xe4,0x0e,0xb3,0x07,0xc4,0x00,0x13,0x05,
+0xa0,0x0f,0x63,0x6b,0xf7,0x0c,0xb7,0x17,0x00,0x40,0x03,0xc7,0x47,0x00,0x13,0x05,
+0xb0,0x0f,0x41,0x8b,0x71,0xe3,0x13,0x07,0x70,0x05,0x23,0x80,0xe7,0x00,0x13,0x07,
+0x80,0xfa,0x23,0x80,0xe7,0x00,0x03,0xc7,0x47,0x00,0x2e,0x89,0x93,0x59,0x26,0x00,
+0x13,0x67,0xc7,0x08,0x23,0x82,0xe7,0x00,0xb7,0x14,0x00,0x40,0x63,0x94,0x09,0x00,
+0x01,0x45,0x8d,0xa8,0x09,0x45,0x39,0x3d,0x22,0x85,0xd5,0x3b,0x33,0x05,0x24,0x41,
+0x11,0x09,0x83,0x27,0xc9,0xff,0xdc,0xc8,0x83,0xc7,0xa4,0x01,0x93,0xe7,0x07,0x01,
+0x03,0xc7,0xa4,0x01,0x62,0x07,0x61,0x87,0xe3,0x4c,0x07,0xfe,0x23,0x8d,0xf4,0x00,
+0x03,0xc7,0xa4,0x01,0x62,0x07,0x61,0x87,0xe3,0x4c,0x07,0xfe,0x23,0x8d,0xf4,0x00,
+0x03,0xc7,0xa4,0x01,0x62,0x07,0x61,0x87,0xe3,0x4c,0x07,0xfe,0x23,0x8d,0xf4,0x00,
+0x03,0xc7,0xa4,0x01,0x62,0x07,0x61,0x87,0xe3,0x4c,0x07,0xfe,0x23,0x8d,0xf4,0x00,
+0xfd,0x19,0x33,0x04,0xa9,0x00,0x63,0x85,0x09,0x00,0x93,0x77,0xf4,0x0f,0xcd,0xf3,
+0xf5,0x33,0x49,0xd5,0x37,0x17,0x00,0x40,0x93,0x07,0x70,0x05,0x23,0x00,0xf7,0x00,
+0x93,0x07,0x80,0xfa,0x23,0x00,0xf7,0x00,0x83,0x47,0x47,0x00,0x93,0xf7,0x37,0x07,
+0x93,0xe7,0x07,0x08,0x23,0x02,0xf7,0x00,0xf2,0x40,0x62,0x44,0xd2,0x44,0x42,0x49,
+0xb2,0x49,0x05,0x61,0x82,0x80,0x01,0x11,0xa1,0x67,0x26,0xca,0x3e,0x95,0x06,0xce,
+0x22,0xcc,0x4a,0xc8,0x4e,0xc6,0x52,0xc4,0xb7,0x07,0x08,0x00,0x93,0x04,0xe0,0x0f,
+0x63,0x71,0xf5,0x04,0xb7,0x17,0x00,0x40,0x03,0xc7,0x47,0x00,0x93,0x04,0xb0,0x0f,
+0x41,0x8b,0x05,0xeb,0x23,0x8d,0x07,0x00,0x1d,0x47,0x23,0x8d,0xe7,0x00,0x2d,0x47,
+0x23,0x8c,0xe7,0x00,0x2e,0x84,0x93,0x54,0x26,0x00,0x11,0x3b,0xf5,0x39,0xed,0x39,
+0xfd,0x59,0x37,0x1a,0x00,0x40,0x13,0x89,0xf4,0xff,0x63,0x1d,0x39,0x01,0x81,0x44,
+0x75,0x39,0xf2,0x40,0x62,0x44,0x26,0x85,0x42,0x49,0xd2,0x44,0xb2,0x49,0x22,0x4a,
+0x05,0x61,0x82,0x80,0xd1,0x39,0xc9,0x39,0xc1,0x39,0xf9,0x31,0x11,0x04,0x03,0x27,
+0x4a,0x01,0x83,0x27,0xc4,0xff,0xe3,0x1d,0xf7,0xfc,0xca,0x84,0xe9,0xb7,0x79,0x71,
+0x4a,0xd0,0x37,0x19,0x00,0x40,0x22,0xd4,0x26,0xd2,0x4e,0xce,0x52,0xcc,0x06,0xd6,
+0x37,0x04,0x28,0x00,0xa5,0x39,0x93,0x04,0xa9,0x01,0x1d,0x4a,0x95,0x49,0x23,0x80,
+0x04,0x00,0x23,0x80,0x44,0x01,0x23,0x0c,0x39,0x01,0x79,0x31,0x71,0x31,0x2a,0xc6,
+0xb1,0x39,0x32,0x45,0x93,0x77,0x15,0x00,0xa9,0xc3,0x7d,0x14,0x6d,0xf0,0x13,0x05,
+0xf0,0x0f,0xb2,0x50,0x22,0x54,0x92,0x54,0x02,0x59,0xf2,0x49,0x62,0x4a,0x45,0x61,
+0x82,0x80,0x13,0x07,0x40,0x04,0x01,0x45,0xe3,0x85,0xe7,0xfe,0x05,0x45,0x59,0x39,
+0x13,0x05,0x40,0x04,0x3d,0x39,0x09,0x45,0x2d,0x39,0x22,0x54,0xb2,0x50,0x92,0x54,
+0x02,0x59,0xf2,0x49,0x62,0x4a,0x45,0x61,0x55,0xb9,0x93,0x77,0xc5,0x07,0xf1,0xfb,
+0x01,0x45,0xc1,0xb7,
+};
+uint8_t flash_op573[ ] ={
+    0x79, 0x71, 0x22, 0xD4, 0x26, 0xD2, 0x5A, 0xC8, 0x06, 0xD6, 0x4A, 0xD0, 0x4E, 0xCE, 0x52, 0xCC, 
+    0x56, 0xCA, 0x5E, 0xC6, 0x93, 0x77, 0x15, 0x00, 0x2A, 0x84, 0x2E, 0x8B, 0xB2, 0x84, 0x9D, 0xEF, 
+    0x93, 0x77, 0x24, 0x00, 0x99, 0xCB, 0xB7, 0x86, 0x07, 0x00, 0x01, 0x46, 0x81, 0x45, 0x05, 0x45, 
+    0x9D, 0x22, 0x93, 0x77, 0xF5, 0x0F, 0x09, 0x45, 0x9D, 0xEB, 0x93, 0x77, 0x44, 0x00, 0x91, 0xCB, 
+    0x85, 0x66, 0x01, 0x46, 0xDA, 0x85, 0x05, 0x45, 0xB9, 0x22, 0x93, 0x77, 0xF5, 0x0F, 0x11, 0x45, 
+    0x99, 0xEF, 0x93, 0x77, 0x84, 0x01, 0x9D, 0xE7, 0x01, 0x45, 0x11, 0xA8, 0x81, 0x46, 0x01, 0x46, 
+    0x81, 0x45, 0x21, 0x45, 0x0D, 0x2A, 0x93, 0x77, 0xF5, 0x0F, 0x05, 0x45, 0xD5, 0xDB, 0xB2, 0x50, 
+    0x22, 0x54, 0x92, 0x54, 0x02, 0x59, 0xF2, 0x49, 0x62, 0x4A, 0xD2, 0x4A, 0x42, 0x4B, 0xB2, 0x4B, 
+    0x45, 0x61, 0x02, 0x90, 0x93, 0x84, 0xF4, 0x0F, 0x93, 0x7B, 0x84, 0x00, 0xA1, 0x80, 0x01, 0x49, 
+    0xB7, 0x5A, 0x00, 0x20, 0x41, 0x88, 0x93, 0x19, 0x89, 0x00, 0x33, 0x8A, 0x69, 0x01, 0x63, 0x9F, 
+    0x0B, 0x00, 0x0D, 0xC8, 0x93, 0x06, 0x00, 0x10, 0x33, 0x86, 0x59, 0x01, 0xD2, 0x85, 0x0D, 0x45, 
+    0xDD, 0x20, 0x13, 0x75, 0xF5, 0x0F, 0x19, 0xCD, 0x41, 0x45, 0x55, 0xBF, 0x93, 0x06, 0x00, 0x10, 
+    0x33, 0x86, 0x59, 0x01, 0xD2, 0x85, 0x09, 0x45, 0xF9, 0x20, 0x13, 0x75, 0xF5, 0x0F, 0x71, 0xD9, 
+    0x21, 0x45, 0x71, 0xBF, 0x05, 0x09, 0xE3, 0x10, 0x99, 0xFC, 0xBD, 0xBF, 0x23, 0x03, 0x04, 0x80, 
+    0x95, 0x47, 0x23, 0x03, 0xF4, 0x80, 0x23, 0x02, 0xA4, 0x80, 0x82, 0x80, 0x83, 0x07, 0x64, 0x80, 
+    0xE3, 0xCE, 0x07, 0xFE, 0x23, 0x03, 0x04, 0x80, 0x82, 0x80, 0x83, 0x07, 0x64, 0x80, 0xE3, 0xCE, 
+    0x07, 0xFE, 0x03, 0x45, 0x44, 0x80, 0x82, 0x80, 0x83, 0x07, 0x64, 0x80, 0xE3, 0xCE, 0x07, 0xFE, 
+    0x23, 0x02, 0xA4, 0x80, 0x82, 0x80, 0x41, 0x11, 0x26, 0xC4, 0x4A, 0xC2, 0x4E, 0xC0, 0x06, 0xC6, 
+    0x13, 0x77, 0xF5, 0x0B, 0xAD, 0x47, 0xAA, 0x89, 0x2E, 0x89, 0x95, 0x44, 0x63, 0x06, 0xF7, 0x00, 
+    0x19, 0x45, 0x6D, 0x37, 0x65, 0x3F, 0x8D, 0x44, 0x4E, 0x85, 0x4D, 0x37, 0xFD, 0x59, 0xFD, 0x14, 
+    0x63, 0x98, 0x34, 0x01, 0xB2, 0x40, 0xA2, 0x44, 0x12, 0x49, 0x82, 0x49, 0x41, 0x01, 0x82, 0x80, 
+    0x13, 0x55, 0x09, 0x01, 0x13, 0x75, 0xF5, 0x0F, 0x45, 0x3F, 0x22, 0x09, 0xCD, 0xB7, 0x01, 0x11, 
+    0x26, 0xCC, 0x06, 0xCE, 0xB7, 0x04, 0x08, 0x00, 0x51, 0x37, 0x15, 0x45, 0x85, 0x3F, 0x71, 0x37, 
+    0x69, 0x37, 0x2A, 0xC6, 0xA5, 0x3F, 0x32, 0x45, 0x93, 0x77, 0x15, 0x00, 0x89, 0xEB, 0x13, 0x65, 
+    0x15, 0x00, 0x13, 0x75, 0xF5, 0x0F, 0xF2, 0x40, 0xE2, 0x44, 0x05, 0x61, 0x82, 0x80, 0xFD, 0x14, 
+    0xE9, 0xFC, 0x01, 0x45, 0xCD, 0xBF, 0x39, 0x71, 0x26, 0xDC, 0x4A, 0xDA, 0x4E, 0xD8, 0x52, 0xD6, 
+    0x56, 0xD4, 0x5A, 0xD2, 0x5E, 0xD0, 0x06, 0xDE, 0x62, 0xCE, 0x66, 0xCC, 0xB7, 0xE7, 0x00, 0xE0, 
+    0x7D, 0x57, 0x83, 0xAA, 0x07, 0x00, 0x22, 0xC6, 0x03, 0xAA, 0x47, 0x00, 0x23, 0xA0, 0xE7, 0x18, 
+    0x23, 0xA2, 0xE7, 0x18, 0xB7, 0x17, 0x00, 0x40, 0x13, 0x07, 0x70, 0x05, 0x23, 0x80, 0xE7, 0x04, 
+    0x13, 0x07, 0x80, 0xFA, 0x23, 0x80, 0xE7, 0x04, 0x83, 0xC7, 0x47, 0x04, 0x13, 0x09, 0x75, 0xFF, 
+    0xB6, 0x84, 0xE2, 0x07, 0x13, 0x79, 0xF9, 0x0F, 0x85, 0x46, 0xAA, 0x89, 0xAE, 0x8B, 0x32, 0x8B, 
+    0x37, 0x24, 0x00, 0x40, 0xE1, 0x87, 0x01, 0x57, 0x63, 0xFA, 0x26, 0x01, 0x63, 0x08, 0xD5, 0x00,  
+    0x89, 0x46, 0x13, 0x07, 0x00, 0x02, 0x63, 0x13, 0xD5, 0x00, 0x01, 0x57, 0xD9, 0x8F, 0x93, 0xF7, 
+    0xF7, 0x0F, 0xB7, 0x1C, 0x00, 0x40, 0x23, 0x82, 0xFC, 0x04, 0x11, 0x47, 0x23, 0x03, 0xE4, 0x80, 
+    0x13, 0x05, 0xF0, 0x0F, 0x65, 0x3D, 0x09, 0x4C, 0xD1, 0x35, 0x63, 0x69, 0x2C, 0x11, 0xB7, 0x07, 
+    0x07, 0x00, 0xBE, 0x9B, 0x37, 0x87, 0x07, 0x00, 0x79, 0x55, 0x63, 0xFE, 0xEB, 0x02, 0xB3, 0x87, 
+    0x9B, 0x00, 0x63, 0x6A, 0xF7, 0x02, 0xA9, 0x47, 0x63, 0x99, 0xF9, 0x06, 0x89, 0xE4, 0x81, 0x44, 
+    0x71, 0x3D, 0x26, 0x85, 0x0D, 0xA0, 0xDE, 0x85, 0x09, 0x45, 0x75, 0x3D, 0x05, 0x0B, 0x03, 0x45, 
+    0xFB, 0xFF, 0xFD, 0x14, 0x85, 0x0B, 0x4D, 0x35, 0x81, 0xC4, 0x93, 0xF7, 0xFB, 0x0F, 0xFD, 0xF7, 
+    0xFD, 0x35, 0x69, 0xFD, 0x7D, 0x55, 0xB7, 0x17, 0x00, 0x40, 0x13, 0x07, 0x70, 0x05, 0x23, 0x80, 
+    0xE7, 0x04, 0x13, 0x07, 0x80, 0xFA, 0x23, 0x80, 0xE7, 0x04, 0x03, 0xC7, 0x47, 0x04, 0x41, 0x8B, 
+    0x23, 0x82, 0xE7, 0x04, 0xF2, 0x50, 0xB7, 0xE7, 0x00, 0xE0, 0x23, 0xA0, 0x57, 0x11, 0x23, 0xA2, 
+    0x47, 0x11, 0xE2, 0x54, 0x32, 0x44, 0x52, 0x59, 0xC2, 0x59, 0x32, 0x5A, 0xA2, 0x5A, 0x12, 0x5B, 
+    0x82, 0x5B, 0x72, 0x4C, 0xE2, 0x4C, 0x21, 0x61, 0x82, 0x80, 0xA5, 0x47, 0x63, 0x95, 0xF9, 0x06, 
+    0x85, 0x69, 0x13, 0x09, 0xF0, 0x0F, 0xB3, 0x06, 0x99, 0x00, 0xB3, 0xF4, 0x2B, 0x01, 0xB6, 0x94, 
+    0x13, 0x49, 0xF9, 0xFF, 0xB3, 0x74, 0x99, 0x00, 0x41, 0x6B, 0x33, 0x79, 0x79, 0x01, 0x85, 0x6B, 
+    0x93, 0x87, 0xF9, 0xFF, 0xB3, 0xF7, 0x27, 0x01, 0x99, 0xE3, 0x63, 0xFC, 0x34, 0x01, 0x93, 0xD9, 
+    0x49, 0x00, 0xC1, 0x47, 0xE3, 0xE6, 0x37, 0xFF, 0x99, 0xBF, 0x05, 0x69, 0xC1, 0x69, 0x7D, 0x19,  
+    0xD9, 0xB7, 0x13, 0x05, 0x80, 0x0D, 0x63, 0x88, 0x69, 0x01, 0x13, 0x05, 0x00, 0x02, 0x63, 0x84, 
+    0x79, 0x01, 0x13, 0x05, 0x10, 0x08, 0xCA, 0x85, 0xFD, 0x3B, 0x91, 0x35, 0x21, 0xDD, 0x4E, 0x99, 
+    0xB3, 0x84, 0x34, 0x41, 0xD9, 0xB7, 0xDE, 0x85, 0x2D, 0x45, 0xF5, 0x33, 0xDA, 0x94, 0xE3, 0x00, 
+    0x9B, 0xF2, 0x05, 0x0B, 0xD9, 0x33, 0xA3, 0x0F, 0xAB, 0xFE, 0xD5, 0xBF, 0x93, 0x87, 0xF9, 0xFF, 
+    0x93, 0xF7, 0xF7, 0x0F, 0x63, 0x6C, 0xFC, 0x08, 0x03, 0xC7, 0x5C, 0x04, 0xB7, 0x07, 0x08, 0x00, 
+    0x13, 0x77, 0x07, 0x02, 0x19, 0xE3, 0xB7, 0x87, 0x07, 0x00, 0x79, 0x55, 0xE3, 0xFD, 0xFB, 0xF0, 
+    0x33, 0x87, 0x9B, 0x00, 0xE3, 0xE9, 0xE7, 0xF0, 0x89, 0x47, 0x63, 0x90, 0xF9, 0x04, 0x89, 0x80, 
+    0x55, 0x49, 0xE3, 0x8E, 0x04, 0xEC, 0xDE, 0x85, 0x09, 0x45, 0x71, 0x3B, 0x11, 0x0B, 0x03, 0x27, 
+    0xCB, 0xFF, 0x91, 0x47, 0x23, 0x20, 0xE4, 0x80, 0x03, 0x07, 0x64, 0x80, 0xE3, 0x4E, 0x07, 0xFE, 
+    0x23, 0x03, 0x24, 0x81, 0xFD, 0x17, 0xED, 0xFB, 0xFD, 0x14, 0x91, 0x0B, 0x81, 0xC4, 0x93, 0xF7, 
+    0xFB, 0x0F, 0xE9, 0xFF, 0x6D, 0x3B, 0x71, 0xF5, 0xF1, 0xB5, 0x85, 0x47, 0xE3, 0x87, 0xF9, 0xF4, 
+    0xDE, 0x85, 0x2D, 0x45, 0x8D, 0x33, 0x13, 0x89, 0xF4, 0xFF, 0xE3, 0x8A, 0x04, 0xE8, 0x35, 0x3B, 
+    0x93, 0x77, 0x39, 0x00, 0x91, 0xEB, 0x83, 0x26, 0x04, 0x80, 0x03, 0x27, 0x0B, 0x00, 0x93, 0x07, 
+    0x4B, 0x00, 0xE3, 0x9F, 0xE6, 0xE6, 0x3E, 0x8B, 0xCA, 0x84, 0xF1, 0xBF, 0xA1, 0x47, 0x63, 0x92, 
+    0xF9, 0x04, 0xB5, 0x3B, 0x81, 0x44, 0x63, 0x8D, 0x0B, 0x00, 0x8D, 0x47, 0x93, 0x04, 0xC0, 0x03, 
+    0x63, 0x88, 0xFB, 0x00, 0x93, 0x04, 0x00, 0x05, 0x63, 0x84, 0x8B, 0x01, 0x93, 0x04, 0x40, 0x04, 
+    0x13, 0x75, 0xC5, 0x07, 0xE3, 0x05, 0x95, 0xE4, 0x19, 0x45, 0xC9, 0x39, 0xC5, 0x31, 0x05, 0x45, 
+    0xF1, 0x31, 0x26, 0x85, 0xD5, 0x39, 0x09, 0x45, 0xC5, 0x39, 0x91, 0x33, 0xE3, 0x19, 0x05, 0xE2, 
+    0x91, 0xBD, 0xE3, 0x86, 0x09, 0xE2, 0xF1, 0x54, 0x25, 0xB5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+uint8_t flash_op307[ ] ={
+	0x93, 0x77, 0x15, 0x00, 0x41, 0x11, 0x99, 0xcf, 0xb7, 0x06, 0x67, 0x45, 0xb7, 0x27, 0x02, 0x40, 
+	0x93, 0x86, 0x36, 0x12, 0x37, 0x97, 0xef, 0xcd, 0xd4, 0xc3, 0x13, 0x07, 0xb7, 0x9a, 0xd8, 0xc3, 
+	0xd4, 0xd3, 0xd8, 0xd3, 0x93, 0x77, 0x25, 0x00, 0x95, 0xc7, 0xb7, 0x27, 0x02, 0x40, 0x98, 0x4b, 
+	0xad, 0x66, 0x37, 0x38, 0x00, 0x40, 0x13, 0x67, 0x47, 0x00, 0x98, 0xcb, 0x98, 0x4b, 0x93, 0x86, 
+	0xa6, 0xaa, 0x13, 0x67, 0x07, 0x04, 0x98, 0xcb, 0xd8, 0x47, 0x05, 0x8b, 0x61, 0xeb, 0x98, 0x4b, 
+	0x6d, 0x9b, 0x98, 0xcb, 0x93, 0x77, 0x45, 0x00, 0xa9, 0xcb, 0x93, 0x07, 0xf6, 0x0f, 0xa1, 0x83, 
+	0x2e, 0xc0, 0x2d, 0x68, 0x81, 0x76, 0x3e, 0xc4, 0xb7, 0x08, 0x02, 0x00, 0xb7, 0x27, 0x02, 0x40, 
+	0x37, 0x33, 0x00, 0x40, 0x13, 0x08, 0xa8, 0xaa, 0xfd, 0x16, 0x98, 0x4b, 0x33, 0x67, 0x17, 0x01, 	
+	0x98, 0xcb, 0x02, 0x47, 0xd8, 0xcb, 0x98, 0x4b, 0x13, 0x67, 0x07, 0x04, 0x98, 0xcb, 0xd8, 0x47, 
+	0x05, 0x8b, 0x41, 0xeb, 0x98, 0x4b, 0x75, 0x8f, 0x98, 0xcb, 0x02, 0x47, 0x13, 0x07, 0x07, 0x10, 
+	0x3a, 0xc0, 0x22, 0x47, 0x7d, 0x17, 0x3a, 0xc4, 0x69, 0xfb, 0x93, 0x77, 0x85, 0x00, 0xd5, 0xcb, 
+	0x93, 0x07, 0xf6, 0x0f, 0x2e, 0xc0, 0xa1, 0x83, 0x3e, 0xc4, 0x37, 0x27, 0x02, 0x40, 0x1c, 0x4b, 
+	0xc1, 0x66, 0x41, 0x68, 0xd5, 0x8f, 0x1c, 0xcb, 0xb7, 0x16, 0x00, 0x20, 0xb7, 0x27, 0x02, 0x40, 
+	0x93, 0x08, 0x00, 0x04, 0x37, 0x03, 0x20, 0x00, 0x98, 0x4b, 0x33, 0x67, 0x07, 0x01, 0x98, 0xcb, 
+	0xd8, 0x47, 0x05, 0x8b, 0x75, 0xff, 0x02, 0x47, 0x3a, 0xc2, 0x46, 0xc6, 0x32, 0x47, 0x0d, 0xef, 
+	0x98, 0x4b, 0x33, 0x67, 0x67, 0x00, 0x98, 0xcb, 0xd8, 0x47, 0x05, 0x8b, 0x75, 0xff, 0xd8, 0x47, 	
+	0x41, 0x8b, 0x39, 0xc3, 0xd8, 0x47, 0xc1, 0x76, 0xfd, 0x16, 0x13, 0x67, 0x07, 0x01, 0xd8, 0xc7, 
+	0x98, 0x4b, 0x21, 0x45, 0x75, 0x8f, 0x98, 0xcb, 0x41, 0x01, 0x02, 0x90, 0x23, 0x20, 0xd8, 0x00, 
+	0x25, 0xb7, 0x23, 0x20, 0x03, 0x01, 0xa5, 0xb7, 0x12, 0x47, 0x13, 0x8e, 0x46, 0x00, 0x94, 0x42, 
+	0x14, 0xc3, 0x12, 0x47, 0x11, 0x07, 0x3a, 0xc2, 0x32, 0x47, 0x7d, 0x17, 0x3a, 0xc6, 0xd8, 0x47, 
+	0x09, 0x8b, 0x75, 0xff, 0xf2, 0x86, 0x5d, 0xb7, 0x02, 0x47, 0x13, 0x07, 0x07, 0x10, 0x3a, 0xc0, 
+	0x22, 0x47, 0x7d, 0x17, 0x3a, 0xc4, 0x49, 0xf3, 0x98, 0x4b, 0xc1, 0x76, 0xfd, 0x16, 0x75, 0x8f, 
+	0x98, 0xcb, 0x41, 0x89, 0x15, 0xc9, 0x2e, 0xc0, 0x0d, 0x06, 0x02, 0xc4, 0x09, 0x82, 0x32, 0xc6, 
+	0xb7, 0x17, 0x00, 0x20, 0x98, 0x43, 0x13, 0x86, 0x47, 0x00, 0xa2, 0x47, 0x82, 0x46, 0x8a, 0x07, 	
+	0xb6, 0x97, 0x9c, 0x43, 0x63, 0x1c, 0xf7, 0x00, 0xa2, 0x47, 0x85, 0x07, 0x3e, 0xc4, 0xa2, 0x46, 
+	0x32, 0x47, 0xb2, 0x87, 0xe3, 0xe0, 0xe6, 0xfe, 0x01, 0x45, 0xbd, 0xbf, 0x41, 0x45, 0xad, 0xbf, 
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,   
+};
+uint8_t flash_op003[ ] ={//v003
+    0x21,0x11,0x22,0xca,0x26,0xc8,0x93,0x77,0x15,0x00,0x99,0xcf,0xb7,0x06,0x67,0x45,
+	0xb7,0x27,0x02,0x40,0x93,0x86,0x36,0x12,0x37,0x97,0xef,0xcd,0xd4,0xc3,0x13,0x07,
+	0xb7,0x9a,0xd8,0xc3,0xd4,0xd3,0xd8,0xd3,0x93,0x77,0x25,0x00,0x9d,0xc7,0xb7,0x27,
+	0x02,0x40,0x98,0x4b,0xad,0x66,0x37,0x33,0x00,0x40,0x13,0x67,0x47,0x00,0x98,0xcb,
+	
+	0x98,0x4b,0x93,0x86,0xa6,0xaa,0x13,0x67,0x07,0x04,0x98,0xcb,0xd8,0x47,0x05,0x8b,
+	0x63,0x16,0x07,0x10,0x98,0x4b,0x6d,0x9b,0x98,0xcb,0x93,0x77,0x45,0x00,0xa9,0xcb,
+	0x93,0x07,0xf6,0x03,0x99,0x83,0x2e,0xc0,0x2d,0x63,0x81,0x76,0x3e,0xc4,0xb7,0x32,
+	0x00,0x40,0xb7,0x27,0x02,0x40,0x13,0x03,0xa3,0xaa,0xfd,0x16,0x98,0x4b,0xb7,0x03,
+	
+	0x02,0x00,0x33,0x67,0x77,0x00,0x98,0xcb,0x02,0x47,0xd8,0xcb,0x98,0x4b,0x13,0x67,
+	0x07,0x04,0x98,0xcb,0xd8,0x47,0x05,0x8b,0x69,0xe7,0x98,0x4b,0x75,0x8f,0x98,0xcb,
+	0x02,0x47,0x13,0x07,0x07,0x04,0x3a,0xc0,0x22,0x47,0x7d,0x17,0x3a,0xc4,0x79,0xf7,
+	0x93,0x77,0x85,0x00,0xf1,0xcf,0x93,0x07,0xf6,0x03,0x2e,0xc0,0x99,0x83,0x37,0x27,
+	
+	0x02,0x40,0x3e,0xc4,0x1c,0x4b,0xc1,0x66,0x2d,0x63,0xd5,0x8f,0x1c,0xcb,0x37,0x07,
+	0x00,0x20,0x13,0x07,0x07,0x20,0xb7,0x27,0x02,0x40,0xb7,0x03,0x08,0x00,0xb7,0x32,
+	0x00,0x40,0x13,0x03,0xa3,0xaa,0x94,0x4b,0xb3,0xe6,0x76,0x00,0x94,0xcb,0xd4,0x47,
+	0x85,0x8a,0xf5,0xfe,0x82,0x46,0xba,0x84,0x37,0x04,0x04,0x00,0x36,0xc2,0xc1,0x46,
+	
+	0x36,0xc6,0x92,0x46,0x84,0x40,0x11,0x07,0x84,0xc2,0x94,0x4b,0xc1,0x8e,0x94,0xcb,
+	0xd4,0x47,0x85,0x8a,0xb1,0xea,0x92,0x46,0xba,0x84,0x91,0x06,0x36,0xc2,0xb2,0x46,
+	0xfd,0x16,0x36,0xc6,0xf9,0xfe,0x82,0x46,0xd4,0xcb,0x94,0x4b,0x93,0xe6,0x06,0x04,
+	0x94,0xcb,0xd4,0x47,0x85,0x8a,0x85,0xee,0xd4,0x47,0xc1,0x8a,0x85,0xce,0xd8,0x47,
+	
+	0xb7,0x06,0xf3,0xff,0xfd,0x16,0x13,0x67,0x07,0x01,0xd8,0xc7,0x98,0x4b,0x21,0x45,
+	0x75,0x8f,0x98,0xcb,0x52,0x44,0xc2,0x44,0x61,0x01,0x02,0x90,0x23,0x20,0xd3,0x00,
+	0xf5,0xb5,0x23,0xa0,0x62,0x00,0x3d,0xb7,0x23,0xa0,0x62,0x00,0x55,0xb7,0x23,0xa0,
+	0x62,0x00,0xc1,0xb7,0x82,0x46,0x93,0x86,0x06,0x04,0x36,0xc0,0xa2,0x46,0xfd,0x16,
+	
+	0x36,0xc4,0xb5,0xf2,0x98,0x4b,0xb7,0x06,0xf3,0xff,0xfd,0x16,0x75,0x8f,0x98,0xcb,
+	0x41,0x89,0x05,0xcd,0x2e,0xc0,0x0d,0x06,0x02,0xc4,0x09,0x82,0xb7,0x07,0x00,0x20,
+	0x32,0xc6,0x93,0x87,0x07,0x20,0x98,0x43,0x13,0x86,0x47,0x00,0xa2,0x47,0x82,0x46,
+	0x8a,0x07,0xb6,0x97,0x9c,0x43,0x63,0x1c,0xf7,0x00,0xa2,0x47,0x85,0x07,0x3e,0xc4,
+
+	0xa2,0x46,0x32,0x47,0xb2,0x87,0xe3,0xe0,0xe6,0xfe,0x01,0x45,0x61,0xb7,0x41,0x45,
+	0x51,0xb7,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+};
+uint8_t flash_op8571[ ]={//CH8571
+    0x31,0x11,0x22,0xc8,0x26,0xc6,0x93,0x77,0x25,0x00,0xb5,0xc3,0xb7,0x17,0x00,0x40,
+	0x13,0x07,0xf0,0x04,0x23,0x8f,0xe7,0x02,0x7d,0x57,0xa3,0x8e,0xe7,0x02,0xa3,0x8d,
+	0x07,0x02,0x79,0x53,0x23,0x8e,0x67,0x02,0xa3,0x8f,0xe7,0x02,0xf5,0x56,0x23,0x8e,
+	0xd7,0x02,0x99,0x42,0xa3,0x8f,0x57,0x02,0x23,0x8e,0x67,0x02,0xa3,0x8f,0xe7,0x02,
+
+	0x23,0x8e,0xd7,0x02,0x93,0x02,0x70,0xfc,0xa3,0x8f,0x57,0x02,0x23,0x8e,0x67,0x02,
+	0xa3,0x8f,0xe7,0x02,0x23,0x8e,0xd7,0x02,0x15,0x47,0xa3,0x8f,0xe7,0x02,0x03,0xc7,
+	0xf7,0x03,0x05,0x8b,0x6d,0xff,0x23,0x8f,0x07,0x02,0xa3,0x8e,0x07,0x02,0x93,0x77,
+	0x45,0x00,0xad,0xcf,0x93,0x07,0xf6,0x0f,0xa1,0x83,0x2e,0xc0,0x3e,0xc2,0xb7,0x17,
+
+	0x00,0x40,0x93,0x86,0xc7,0x03,0xf9,0x53,0x7d,0x53,0xf5,0x52,0x13,0x04,0x10,0xf8,
+	0x23,0x80,0x76,0x00,0xa3,0x8f,0x67,0x02,0x23,0x80,0x56,0x00,0xa3,0x8f,0x87,0x02,
+	0x02,0x47,0x41,0x83,0x13,0x77,0xf7,0x0f,0xa3,0x8f,0xe7,0x02,0x02,0x47,0x21,0x83,
+	0x13,0x77,0xf7,0x0f,0xa3,0x8f,0xe7,0x02,0x02,0x47,0x13,0x77,0xf7,0x0f,0xa3,0x8f,
+
+	0xe7,0x02,0x23,0x80,0x76,0x00,0xa3,0x8f,0x67,0x02,0x23,0x80,0x56,0x00,0x15,0x47,
+	0xa3,0x8f,0xe7,0x02,0x03,0xc7,0xf7,0x03,0x05,0x8b,0x6d,0xff,0x02,0x47,0x13,0x07,
+	0x07,0x10,0x3a,0xc0,0x12,0x47,0x7d,0x17,0x3a,0xc2,0x5d,0xf3,0x93,0x77,0x85,0x00,
+	0xdd,0xcf,0x93,0x07,0xf6,0x0f,0xa1,0x83,0x2e,0xc0,0x3e,0xc2,0xb7,0x17,0x00,0x40,
+
+	0x37,0x17,0x00,0x20,0x13,0x84,0xd7,0x03,0xfd,0x52,0xf9,0x56,0x75,0x53,0x93,0x04,
+	0xf0,0x04,0x23,0x8f,0x97,0x02,0x23,0x00,0x54,0x00,0xa3,0x8d,0x07,0x02,0x23,0x8e,
+	0xd7,0x02,0xa3,0x8f,0x57,0x02,0x23,0x8e,0x67,0x02,0x99,0x44,0xa3,0x8f,0x97,0x02,
+	0x23,0x8e,0xd7,0x02,0xa3,0x8f,0x57,0x02,0x23,0x8e,0x67,0x02,0x89,0x43,0xa3,0x8f,
+
+	0x77,0x02,0x82,0x43,0x93,0x04,0xf0,0x0f,0x93,0xd3,0x03,0x01,0x93,0xf3,0xf3,0x0f,
+	0xa3,0x8f,0x77,0x02,0x82,0x43,0x93,0xd3,0x83,0x00,0x93,0xf3,0xf3,0x0f,0xa3,0x8f,
+	0x77,0x02,0x82,0x43,0x93,0xf3,0xf3,0x0f,0xa3,0x8f,0x77,0x02,0x02,0xc4,0xa2,0x43,
+	0x63,0xf8,0x74,0x10,0x23,0x8e,0xd7,0x02,0xfd,0x54,0xa3,0x8f,0x97,0x02,0x23,0x8e,
+
+	0x67,0x02,0x95,0x43,0xa3,0x8f,0x77,0x02,0x83,0xc3,0xf7,0x03,0x93,0xf3,0x13,0x00,
+	0xe3,0x9c,0x03,0xfe,0x23,0x8f,0x07,0x02,0x23,0x00,0x04,0x00,0x82,0x43,0x93,0x83,
+	0x03,0x10,0x1e,0xc0,0x92,0x43,0xfd,0x13,0x1e,0xc2,0xe3,0x92,0x03,0xf6,0x41,0x89,
+	0x61,0xc1,0x13,0x06,0xf6,0x0f,0x2e,0xc0,0x21,0x82,0xb7,0x17,0x00,0x40,0x32,0xc2,
+
+	0xb7,0x16,0x00,0x20,0x13,0x85,0xe7,0x03,0x93,0x02,0xf0,0x04,0x7d,0x57,0x79,0x56,
+	0xf5,0x55,0x23,0x00,0x55,0x00,0xa3,0x8e,0xe7,0x02,0xa3,0x8d,0x07,0x02,0x23,0x8e,
+	0xc7,0x02,0xa3,0x8f,0xe7,0x02,0x23,0x8e,0xb7,0x02,0x19,0x44,0xa3,0x8f,0x87,0x02,
+	0x23,0x8e,0xc7,0x02,0xa3,0x8f,0xe7,0x02,0x23,0x8e,0xb7,0x02,0x2d,0x44,0xa3,0x8f,
+
+	0x87,0x02,0x02,0x43,0x93,0x03,0xf0,0x0f,0x13,0x53,0x03,0x01,0x13,0x73,0xf3,0x0f,
+	0xa3,0x8f,0x67,0x02,0x02,0x43,0x13,0x53,0x83,0x00,0x13,0x73,0xf3,0x0f,0xa3,0x8f,
+	0x67,0x02,0x02,0x43,0x13,0x73,0xf3,0x0f,0xa3,0x8f,0x67,0x02,0xa3,0x8f,0x07,0x02,
+	0x02,0xc4,0x22,0x43,0x63,0xf1,0x63,0x06,0x23,0x8e,0xc7,0x02,0xa3,0x8f,0xe7,0x02,
+
+	0x23,0x8e,0xb7,0x02,0x15,0x43,0xa3,0x8f,0x67,0x02,0x03,0xc3,0xf7,0x03,0x13,0x73,
+	0x13,0x00,0xe3,0x1c,0x03,0xfe,0x23,0x00,0x05,0x00,0xa3,0x8e,0x07,0x02,0x02,0x43,
+	0x13,0x03,0x03,0x10,0x1a,0xc0,0x12,0x43,0x7d,0x13,0x1a,0xc2,0xe3,0x13,0x03,0xf6,
+	0xb7,0x17,0x00,0x40,0x23,0x8f,0x07,0x02,0xa3,0x8e,0x07,0x02,0x01,0x45,0xb9,0xa8,
+
+	0x83,0x43,0x07,0x00,0x05,0x07,0x93,0xf3,0xf3,0x0f,0xa3,0x8f,0x77,0x02,0xa2,0x43,
+	0x85,0x03,0x1e,0xc4,0xe9,0xbd,0x83,0xc4,0xf7,0x03,0x13,0x84,0x16,0x00,0x83,0xc6,
+	0x06,0x00,0x13,0x83,0xf7,0x03,0x93,0xf6,0xf6,0x0f,0x63,0x8d,0x96,0x02,0x79,0x57,
+	0x23,0x8e,0xe7,0x02,0x7d,0x57,0xa3,0x8f,0xe7,0x02,0x75,0x57,0x23,0x8e,0xe7,0x02,
+
+	0x95,0x47,0x23,0x00,0xf3,0x00,0xb7,0x17,0x00,0x40,0x03,0xc7,0xf7,0x03,0x05,0x8b,
+	0x6d,0xff,0x23,0x8f,0x07,0x02,0xa3,0x8e,0x07,0x02,0x41,0x45,0x42,0x44,0xb2,0x44,
+	0x51,0x01,0x02,0x90,0xa2,0x46,0x85,0x06,0x36,0xc4,0xa2,0x86,0x99,0xb7,0xff,0xff,
+	0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+
+};
+
+void wlink_ramcodewrite(uint8_t *buffer, int size)
+{
+	unsigned long len = 64;
+	int i = 0;
+	while (size >= 64)
+	{
+		pWriteData(0, 2, buffer + 64 * i, &len);
+		size -= 64;
+		i++;
+	}
+	if (size)
+	{
+		len = size;
+		pWriteData(0, 2, buffer + 64 * i, &len);
+	}
+}
+
+void wlink_getromram(uint32_t *rom,uint32_t *ram){
+	
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	bool type_A=false;
+	bool type_B=false;
+	bool type_C=false;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x0d;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x04;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	
+	if(chip_type==0x30700508 ||chip_type==0x30710508 ||chip_type==0x30730508 ||chip_type==0x30300504 ||chip_type==0x30310504)
+		type_A=true;
+	if(chip_type==0x30720508||chip_type==0x30740508)
+		type_C=true;
+	if(chip_type==0x2034050c||chip_type==0x2080050c||chip_type==0x2081050c||chip_type==0x2082050c||chip_type==0x2083050c)
+		type_B=true;
+	switch(rxbuf[3]){
+		case 0:
+			 if(type_B){
+				 *rom=128;
+                 *ram=64;
+			 }
+			else if(type_A){
+				 *rom=192;
+                 *ram=128;
+			 }
+			else if(type_C){
+				 *rom=192;
+                 *ram=128;
+			}
+			else if(riscvchip==3){
+				 *rom=96;
+                 *ram=32;
+			}else{
+ 				 *rom=0;
+                 *ram=0;
+			}
+			break;
+		case 1:
+			 if(type_B){
+				 *rom=144;
+                 *ram=48;
+			 }
+			else if(type_A){
+				 *rom=224;
+                 *ram=96;
+			 }
+			else if(type_C){
+				 *rom=224;
+                 *ram=96;
+			}
+			else if(riscvchip==3){
+				 *rom=64;
+                 *ram=64;				 
+			}else{
+ 				 *rom=0;
+                 *ram=0;
+			}
+			break;
+		case 2:
+			 if(type_B){
+				 *rom=160;
+                 *ram=32;
+			 }
+			else if(type_A){
+				 *rom=256;
+                 *ram=64;
+			 }
+			else if(type_C){
+				 *rom=0;
+                 *ram=0;
+			}else if(riscvchip==3){
+				 *rom=32;
+                 *ram=96;
+			}else{
+ 				 *rom=0;
+                 *ram=0;
+			}
+			break;
+		case 3:
+			 if(type_B){
+				 *rom=160;
+                 *ram=32;
+			 }
+			else if(type_A){
+				 *rom=288;
+                 *ram=32;
+			 }
+			else if(type_C){
+				 *rom=0;
+                 *ram=0;
+			}
+			else if(riscvchip==3){
+				 *rom=32;
+                 *ram=96;
+			}else{
+ 				 *rom=0;
+                 *ram=0;
+			}
+			break;
+		default:
+				 *rom=0;
+                 *ram=0;
+			  break;
+	}
+
+}
+void readmcause();
+unsigned char DMI_OP(	  
+	unsigned long iIndex, 
+	unsigned char iAddr,
+	unsigned long iData,
+	unsigned char iOP,
+	unsigned char *oAddr,
+	unsigned long *oData,
+	unsigned char *oOP)
+{
+	unsigned char Txbuf[9];
+	unsigned char Rxbuf[9];
+	unsigned long len;
+	unsigned char *pData;
+	unsigned char retrytime;
+	Txbuf[0] = 0x81;
+	Txbuf[1] = 0x08;
+	Txbuf[2] = 0x06;
+	Txbuf[3] = iAddr;
+	Txbuf[4] = (unsigned char)(iData >> 24);
+	Txbuf[5] = (unsigned char)(iData >> 16);
+	Txbuf[6] = (unsigned char)(iData >> 8);
+	Txbuf[7] = (unsigned char)(iData);
+	Txbuf[8] = iOP;
+	retrytime = 0;
+RETRY:
+	len = 9;
+	if (pWriteData(gIndex, 1, Txbuf, &len))
+	{
+		memset(Rxbuf, 0, sizeof(Rxbuf));
+		len = 9;
+		
+		if (pReadData(gIndex, 1, Rxbuf, &len))
+		{
+			
+			*oAddr = Rxbuf[3];
+			if (oData)
+			{
+				pData = (unsigned char *)oData;
+				*pData = Rxbuf[7];
+				*(pData + 1) = Rxbuf[6];
+				*(pData + 2) = Rxbuf[5];
+				*(pData + 3) = Rxbuf[4];
+			}
+			*oOP = Rxbuf[8];
+		
+			retrytime++;
+
+			if (Rxbuf[8] == 2 && Rxbuf[6] == 3)
+			{
+				readmcause();
+			}
+
+			return true;
+		}
+	}
+	return false;
+}
+
+int  wlink_reset()
+{
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x0b;
+	txbuf[2] = 0x01;	
+	txbuf[3] = 0x03;
+	unsigned char oAddr;
+	unsigned long oData;
+	unsigned char oOP;
+	unsigned char iAddr;
+	if(riscvchip==0x2)
+		txbuf[3]=0x02;
+	DMI_OP(0, 0x10, 0x80000001, 2, &oAddr, &oData, &oOP);
+	usleep(1000);
+	oAddr = 0;
+	oData = 0;
+	oOP = 0;
+	iAddr = 0;
+	DMI_OP(0, 0x11, iAddr, 1, &oAddr, &oData, &oOP);
+	usleep(1000);
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	usleep(1000);
+	usleep(1000);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	DMI_OP(0, 0x10, 0x80000001, 2, &oAddr, &oData, &oOP);
+	usleep(1000);
+	DMI_OP(0, 0x11, iAddr, 1, &oAddr, &oData, &oOP);
+	return 0;
+}
+int wlink_quitreset(void)
+{
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x0b;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x01;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	usleep(300000);
+	return 0;
+}
+int wlnik_protect_check(void){
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x06;
+	txbuf[2] = 0x01;	
+	txbuf[3] = 0x01;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	if (((rxbuf[0] == 0x82) && (rxbuf[1] == 0x06) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x01)))
+			return  4;
+	if (((rxbuf[0] == 0x82) && (rxbuf[1] == 0x06) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x02)))
+			return 5 ;
+	return ERROR_FAIL;
+
+}
+int  wlink_flash_protect(bool stat){
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x06;
+	txbuf[2] = 0x01;
+	if(stat)
+		txbuf[3] = 0x03;
+	else 
+		txbuf[3] = 0x02;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	if (((rxbuf[0] == 0x82) && (rxbuf[1] == 0x06) && (rxbuf[2] == 0x01) && (rxbuf[3] == txbuf[3]))){
+		 wlink_reset();
+		 usleep(300000);
+		int ret=wlnik_protect_check();
+		if((stat) && (ret == 4))
+			return ERROR_OK;
+		if((!stat) && (ret == 5))
+			return ERROR_OK;
+	}
+	return ERROR_FAIL;
+
+
+}
+
+int wlink_ready_write(uint32_t address,uint32_t count)
+{
+	
+	unsigned char txbuf[24];
+	unsigned char rxbuf[24];
+	unsigned long len = 4;
+	unsigned long chipiaddr1 = chipiaddr + address;
+	if(chipiaddr1 >= 0x10000000)
+		chipiaddr1-=0x08000000;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x06;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x01;
+	txbuf[2] = 0x08;
+	txbuf[3] = (uint8_t)(chipiaddr1 >> 24);
+	txbuf[4] = (uint8_t)(chipiaddr1 >> 16);
+	txbuf[5] = (uint8_t)(chipiaddr1 >> 8);
+	txbuf[6] = (uint8_t)chipiaddr1;
+	txbuf[7] = (uint8_t)(count >> 24);
+	txbuf[8] = (uint8_t)(count >> 16);
+	txbuf[9] = (uint8_t)(count >> 8);
+	txbuf[10]= (uint8_t)count;
+	len = 11;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x05;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	switch (riscvchip)
+	{
+	case 3:
+		wlink_ramcodewrite(flash_op569, sizeof(flash_op569));
+		break;
+	case 1:
+		wlink_ramcodewrite(flash_op103, sizeof(flash_op103));
+		break;
+	case 2:
+		wlink_ramcodewrite(flash_op573, sizeof(flash_op573));
+		break;
+	case 5:
+	case 6:
+		wlink_ramcodewrite(flash_op307, sizeof(flash_op307));
+		break;
+	case 9:
+	    wlink_ramcodewrite(flash_op003,sizeof(flash_op003));
+		break;
+	case 0x0a:
+	    wlink_ramcodewrite(flash_op8571,sizeof(flash_op8571));
+		break;
+	default:;
+	}
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x07;
+	if ((riscvchip == 0x1) ||(pageerase))
+	{
+		txbuf[3] = 0x0b;
+	}
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	return rxbuf[3];
+}
+
+
+void wlink_endprogram(void)
+{
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x08;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+}
+
+int wlink_fastprogram(uint8_t *buffer,int packsize)
+{
+	unsigned long len = 64;
+	unsigned char rxbuf[4];
+	for (int i = 0; i < packsize/64; i++)
+	{
+		pWriteData(0, 2, (buffer + i * 64), &len);
+		len = 64;
+	}
+	// usleep(1000);
+	// for (int i = 0; i < 4 * 1024; i++)
+	// {
+	// 	buffer[i] = 0xff;
+	// }
+	len=4;
+	if(pReadData(0, 2, rxbuf, &len)){
+		if((rxbuf[3]==0x02) ||(rxbuf[3]==0x04))
+			return ERROR_OK;
+	}
+	return ERROR_FAIL;
+}
+
+
+
+unsigned char WriteNonFullPage(unsigned long iaddr,
+							   unsigned char *ibuff,
+							   unsigned long ilen)
+{
+	unsigned char Txbuf[pagesize];
+	unsigned char Rxbuf[pagesize];
+	unsigned long len;
+	unsigned char *pData;
+	unsigned char retrytime;
+	unsigned char i = 0;
+	Txbuf[0] = 0x81;
+	Txbuf[1] = 0x0A;
+	Txbuf[2] = 0x05;
+	iaddr += chipiaddr;
+	Txbuf[3] = (unsigned char)(iaddr >> 24);
+	Txbuf[4] = (unsigned char)(iaddr >> 16);
+	Txbuf[5] = (unsigned char)(iaddr >> 8);
+	Txbuf[6] = (unsigned char)(iaddr);
+	Txbuf[7] = (unsigned char)ilen;
+	retrytime = 0;
+	len = 8;
+	if ((riscvchip == 0x03) || (riscvchip == 0x02))
+	{
+		if (pWriteData(0, 1, Txbuf, &len))
+		{
+			memset(Rxbuf, 0, sizeof(Rxbuf));
+			len = 9;
+			if (pReadData(0, 1, Rxbuf, &len))
+			{
+				if (ilen <= 64)
+				{
+					len = ilen;
+					if (pWriteData(0, 2, ibuff, &len))
+					{
+					}
+					len = 4;
+					if (pReadData(0, 2, Rxbuf, &len))
+					{
+					}
+					return 1;
+				}
+				while (ilen > 64)
+				{
+					len = 64;
+					pWriteData(0, 2, &ibuff[i], &len);
+					ilen = ilen - 64;
+					i = i + 64;
+				}
+				if (ilen)
+				{
+					pWriteData(0, 2, &ibuff[i], &ilen);
+				}
+				len = 4;
+				pReadData(0, 2, Rxbuf, &len);
+			}
+			return 1;
+		}
+		return 0;
+	}
+
+	if ((riscvchip == 0x01) || (riscvchip == 0x06)||(riscvchip == 0x05) || (riscvchip == 0x09)|| (riscvchip == 0x0a))
+	{
+		if (pWriteData(0, 1, Txbuf, &len))
+		{
+			memset(Rxbuf, 0, sizeof(Rxbuf));
+			len = 9;
+			if (pReadData(0, 1, Rxbuf, &len))
+			{
+				if (ilen <= 64)
+				{
+					len = ilen;
+					if (pWriteData(0, 2, ibuff, &len))
+					{
+					}
+					len = 4;
+					if (pReadData(0, 2, Rxbuf, &len))
+					{
+					}
+				}
+				else
+				{
+					len = 64;
+					if (pWriteData(0, 2, ibuff, &len))
+					{
+					}
+					len = ilen - 64;
+					if (pWriteData(0, 2, &ibuff[64], &len))
+					{
+					}
+					len = 4;
+					if (pReadData(0, 2, Rxbuf, &len))
+					{
+					}
+				}
+				return 1;
+			}
+		}
+		return 0;
+	}
+}
+int wlink_verify(unsigned long length, unsigned char *buffer)
+{
+	unsigned char txbuf[12];
+	unsigned char rxbuf[12];
+	unsigned long len = 4;
+	int packsize=4096;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x0f;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x02;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x0d;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x01;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 7;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[3] = 0x02;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 8;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x06;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x01;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x0A;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x01;
+	txbuf[2] = 0x08;
+	txbuf[3] = (uint8_t)(chipiaddr >> 24);
+	txbuf[4] = (uint8_t)(chipiaddr >> 16);
+	txbuf[5] = (uint8_t)(chipiaddr >> 8);
+	txbuf[6] = (uint8_t)chipiaddr;
+	txbuf[7] = (uint8_t)(length >> 24);
+	txbuf[8] = (uint8_t)(length >> 16);
+	txbuf[9] = (uint8_t)(length >> 8);
+	txbuf[10] = (uint8_t)(length);
+	len = 11;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x05;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+
+	switch (riscvchip)
+	{
+	case 3:
+		wlink_ramcodewrite(flash_op569, sizeof(flash_op569));
+		break;
+	case 1:
+
+		wlink_ramcodewrite(flash_op103, sizeof(flash_op103));
+		break;
+	case 2:
+		wlink_ramcodewrite(flash_op573, sizeof(flash_op573));
+		break;
+	case 5:
+	case 6:
+		wlink_ramcodewrite(flash_op307, sizeof(flash_op307));
+		break;
+	case 9:
+	    wlink_ramcodewrite(flash_op003,sizeof(flash_op003));
+		packsize=1024;
+		break;
+	case 0x0a:
+		wlink_ramcodewrite(flash_op8571, sizeof(flash_op8571));
+		break;
+	default:;
+	}
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x09;
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+	len = 4;
+	txbuf[3] = 0x03;
+	pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	pReadData(0, 1, rxbuf, &len);
+/*	int i = 0;
+	int ret;*/
+/*	switch (riscvchip)
+	{
+	case 3:
+		ret = length % 256;
+		if (ret)
+		{
+			for (int j = 0; j < (256 - ret); j++)
+			{
+				*(buffer + length + j) = 0xff;
+			}
+			while (length - ret + 256)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+			break;
+		}
+		else
+		{
+			while (length)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+			break;
+		}
+	case 1:
+		ret = length % 128;
+		if (ret)
+		{
+			for (int j = 0; j < (128 - ret); j++)
+			{
+				*(buffer + length + j) = 0xff;
+			}
+			while (length - ret + 128)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+			break;
+		}
+		else
+		{
+			while (length)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+			break;
+		}
+	case 2:
+		ret = length % 256;
+		i = 0;
+		if (ret)
+		{
+			for (int j = 0; j < (256 - ret); j++)
+			{
+				*(buffer + length + j) = 0xff;
+			}
+
+			while (length - ret + 256)
+			{
+				len = 64;
+
+				pWriteData(0, 2, buffer + i, &len);
+
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+
+			if (i < 4096)
+			{
+				len = 4;
+				pReadData(0, 2, rxbuf, &len);
+				if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+				{
+				}
+				else
+				{
+					LOG_ERROR("Verify failed");
+					return ERROR_FAIL;
+				}
+			}
+			break;
+		}
+		else
+		{
+			while (length)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+			break;
+		}
+	case 5:
+	case 6:
+		ret = length % 256;
+		if (ret)
+		{
+			for (int j = 0; j < (256 - ret); j++)
+			{
+				*(buffer + length + j) = 0xff;
+			}
+			while (length - ret + 256)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+
+			break;
+		}
+		else
+		{
+			while (length)
+			{
+				len = 64;
+				pWriteData(0, 2, buffer + i, &len);
+				i += 64;
+				length -= 64;
+				if (!(i % 4096))
+				{
+					len = 4;
+					pReadData(0, 2, rxbuf, &len);
+					if (((rxbuf[0] == 0x41) && (rxbuf[1] == 0x01) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x04)))
+					{
+					}
+					else
+					{
+						LOG_ERROR("Verify failed");
+						return ERROR_FAIL;
+					}
+				}
+			}
+
+			break;
+		}
+
+	default:
+		break;
+	}*/
+	uint8_t* buf_bin;
+	buf_bin=malloc(packsize);
+	memset(buf_bin,0xff,packsize);
+	
+	int binlength = length;
+	
+	
+	if (binlength <= packsize)
+	{
+		for (int i = 0; i < length; i++)
+		{
+			buf_bin[i] = *(buffer + i);
+		}
+		int ret = wlink_fastprogram(buf_bin,packsize);
+		if (ret != ERROR_OK)
+		{
+			return ERROR_FAIL;
+		}
+	}
+	else
+	{
+		while (binlength >= packsize)
+		{
+			for (int i = 0; i < packsize; i++)
+			{
+				buf_bin[i] = *(buffer + i);
+			}
+			int ret = wlink_fastprogram(buf_bin,packsize);
+			if (ret != ERROR_OK)
+			{
+				return ERROR_FAIL;
+			}
+			binlength -= packsize;
+			buffer += packsize;
+		}
+		if (binlength > 0)
+		{
+			memset(buf_bin,0xff,packsize);
+			for (int i = 0; i < binlength; i++)
+			{
+				buf_bin[i] = *(buffer + i);
+			}
+			int ret = wlink_fastprogram(buf_bin,packsize);
+			if (ret != ERROR_OK)
+			{
+				return ERROR_FAIL;
+			}
+		}
+	}
+	LOG_INFO("Verify Success");
+	return ERROR_OK;
+}
+int wlink_erase(void)
+{
+	int ret;
+	unsigned char txbuf[4];
+	unsigned char rxbuf[4];
+	unsigned long len = 4;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x02;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x01;
+	ret=pWriteData(0, 1, txbuf, &len);
+	len = 4;
+	ret=pReadData(0, 1, rxbuf, &len);
+	return ret;
+}
+void readmcause()
+{
+	unsigned char oAddr;
+	unsigned long oData;
+	unsigned char oOP;
+	DMI_OP(0, 0x16, 0x00000700, 2, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x17, 0x220342, 2, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x16, 0, 1, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x4, 0, 1, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x17, 0x220343, 2, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x16, 0, 1, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x4, 0, 1, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x20, 0, 1, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x21, 0, 1, &oAddr, &oData, &oOP);
+	DMI_OP(0, 0x22, 0, 1, &oAddr, &oData, &oOP);
+}
+
+int wlink_execute_queue(void)
+{
+	return ERROR_OK;
+}
+void wlink_endprocess(void)
+{
+	
+		unsigned char txbuf[4];
+		unsigned char rxbuf[4];
+		unsigned long len = 4;
+		txbuf[0] = 0x81;
+		txbuf[1] = 0x0d;
+		txbuf[2] = 0x01;
+		txbuf[3] = 0xff;
+		len = 4;
+		pWriteData(0, 1, txbuf, &len);
+		len = 4;
+		pReadData(0, 1, rxbuf, &len);
+	
+	
+}
+
+int wlink_init(void)
+{	
+	unsigned char txbuf[4];
+	unsigned char rxbuf[20];
+	char * wlink_name=NULL;
+	uint64_t old_dpc_value, new_dpc_value, t6_new, t6_old;
+	
+	uint32_t dmcontrol;
+	txbuf[0] = 0x81;
+	txbuf[1] = 0x0d;
+	txbuf[2] = 0x01;
+	txbuf[3] = 0x01;
+	unsigned long len = 4;
+
+#ifdef _WIN32
+	OSVERSIONINFO version;
+
+	version.dwOSVersionInfoSize = sizeof version;
+	if (!GetVersionEx(&version))
+	{
+		LOG_ERROR("GetVersionEx error");
+		return ERROR_FAIL;
+	}
+	if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
+	{
+		LOG_ERROR("Not Win32 Platform");
+		return ERROR_FAIL;
+	}
+	if (hModule == 0)
+	{
+		hModule = LoadLibrary("WCHLinkDll.dll");
+		if (hModule)
+		{
+			pOpenDev = (pCH375OpenDevice)GetProcAddress(hModule, "CH375OpenDevice");
+			pCloseDev = (pCH375CloseDevice)GetProcAddress(hModule, "CH375CloseDevice");
+			pSetTimeout = (pCH375SetTimeout)GetProcAddress(hModule, "CH375SetTimeout");
+			pReadData = (pCH375ReadEndP)GetProcAddress(hModule, "CH375ReadEndP");
+			pWriteData = (pCH375WriteEndP)GetProcAddress(hModule, "CH375WriteEndP");
+			if (pOpenDev == NULL || pCloseDev == NULL || pSetTimeout == NULL || pReadData == NULL || pWriteData == NULL)
+			{
+				LOG_ERROR("GetProcAddress error");
+				return ERROR_FAIL;
+			}
+			if (pOpenDev(gIndex) == -1)
+			{
+				gOpen = FALSE;
+				LOG_ERROR("WLink Open Error");
+				return ERROR_FAIL;
+			}
+			pSetTimeout(gIndex, 5000, 5000);
+		}
+	}
+#else if
+
+	if (jtag_libusb_open(wlink_vids, wlink_pids, NULL, &wfd, NULL) != ERROR_OK)
+	{
+		LOG_ERROR("open failed");
+		goto error_wlink;
+	}
+	jtag_libusb_set_configuration(wfd, 0);
+	if (libusb_claim_interface(wfd, 0) != ERROR_OK)
+	{
+		LOG_ERROR("claim interface failed");
+		goto error_wlink;
+	}
+
+#endif
+	len = 4;
+	pWriteData(0, 1, txbuf, &len);
+	len = 7;
+	if (pReadData(0, 1, rxbuf, &len))
+	{
+		switch (rxbuf[5])
+		{
+		case 1:
+			wlink_name="WCH-Link-CH549  mod:RV";
+			wlink549=true;
+			break;
+		case 2:
+			wlink_name="WCH-LinkE-CH32V307  mod:RV";
+			break;
+		case 3:
+			wlink_name="WCH-LinkS-CH32V203  mod:RV";
+			break;
+		case 4:
+			wlink_name="WCH-LinkB  mod:RV";
+			break;
+		default:
+			LOG_ERROR("unknow WCH-LINK ");	
+			goto error_wlink;
+			break;
+		}
+		LOG_INFO("%s version %d.%d ",wlink_name, rxbuf[3], rxbuf[4]);
+	
+		txbuf[3] = 0x02;
+		len = 4;
+		pWriteData(0, 1, txbuf, &len);
+		len = 8;
+		pReadData(0, 1, rxbuf, &len);
+		if (((rxbuf[0] == 0x81) && (rxbuf[1] == 0x55) && (rxbuf[2] == 0x01) && (rxbuf[3] == 0x01)))
+		{
+			LOG_ERROR(" WCH-Link failed to connect with riscvchip");
+			LOG_ERROR(" 1.Make sure the two-line debug interface has been opened. If not, set board to boot mode then use ISP tool to open it");
+			LOG_ERROR(" 2.Please check your physical link connection");
+			if(wlink549)
+				LOG_ERROR(" if your chip is CH32V00X,WCH-Link-CH549 does not support this chip, please use WCH-LinkE");
+			goto error_wlink;
+		}
+		chip_type=(((unsigned int)rxbuf[4])<<24) + (((unsigned int)rxbuf[5])<<16) + (((unsigned int)rxbuf[6])<<8) +(((unsigned int) rxbuf[7]));
+		chip_type = chip_type & 0xffffff0f;
+		
+		switch (rxbuf[3])
+		{
+		case 1:
+		{
+			riscvchip = 0x01;
+			chipiaddr = 0x08000000;
+			pagesize = 128;		
+			// txbuf[0] = 0x81;
+			// txbuf[1] = 0x06;
+			// txbuf[2] = 0x01;
+			// txbuf[3] = 0x01;
+			// len = 4;
+			// pWriteData(0, 1, txbuf, &len);
+			// len = 4;
+			// pReadData(0, 1, rxbuf, &len);
+			// if(rxbuf[2]==rxbuf[3]==1){
+			// 	LOG_ERROR("Read-Protect Status Currently Enabled");
+			// 	goto error_wlink;
+				 
+			// }
+			txbuf[0] = 0x81;
+			txbuf[1] = 0x0d;
+			txbuf[2] = 0x01;
+			txbuf[3] = 0x03;
+			len = 4;
+			pWriteData(0, 1, txbuf, &len);
+			len = 4;
+			if(pReadData(0, 1, rxbuf, &len)){
+					uint64_t old_dpc_value, new_dpc_value, t6_new, t6_old;
+					uint32_t dmcontrol;
+					uint32_t addr = 4;
+					unsigned char oAddr;
+					unsigned long oData;
+					unsigned char oOP;
+					unsigned char iAddr;
+					unsigned char Txbuf[52] = {0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+											   0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+											   0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
+											   0x73, 0x00, 0x10, 0x00};				
+					DMI_OP(0, 0x20, 0x0002a283, 2, &oAddr, &oData, &oOP);
+					DMI_OP(0, 0x21, 0x00100073, 2, &oAddr, &oData, &oOP);
+					DMI_OP(0, 0x04, 0, 2, &oAddr, &oData, &oOP);
+					DMI_OP(0, 0x17, 0x00271005, 2, &oAddr, &oData, &oOP);
+					DMI_OP(0, 0x17, 0x00221005, 2, &oAddr, &oData, &oOP);
+					DMI_OP(0, 0x04, iAddr, 1, &oAddr, &oData, &oOP);
+					WriteNonFullPage(addr, Txbuf, sizeof(Txbuf));					
+					int ret = DMI_OP(0, 0x04, 0x00000020, 2, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x17, 0x0023101F, 2, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x16, iAddr, 1, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x20, 0x000f8067, 2, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x21, 0x00100073, 2, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x17, 0x00241000, 2, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x16, iAddr, 1, &oAddr, &oData, &oOP);
+					usleep(1000);
+					DMI_OP(0, 0x10, 0x80000003, 2, &oAddr, &oData, &oOP);
+					usleep(300000);
+					wlink_reset();
+					
+				}
+			break;
+		}
+		case 2:
+		{
+			riscvchip = 0x02;
+			chipiaddr = 0x00000000;
+			pagesize = 256;
+			LOG_WARNING(" The debug interface has been opened,there is a risk of code leakage ,ensure that the debug interface has been closed before leaving factory !");
+			break;
+		}
+		case 3:
+		{
+			riscvchip = 0x03;
+			chipiaddr = 0x0000;
+			pagesize = 256;
+			LOG_WARNING(" The debug interface has been opened,there is a risk of code leakage ,ensure that the debug interface has been closed before leaving factory !");
+			txbuf[0] = 0x81;
+			txbuf[1] = 0x0d;
+			txbuf[2] = 0x01;
+			txbuf[3] = 0x04;
+		
+			len=4;
+			pWriteData(0, 1, txbuf, &len);
+			len = 4;
+			pReadData(0, 1, rxbuf, &len);
+
+			switch (rxbuf[3])
+			{
+			case 0:
+			{
+				ramaddr = 0x8000;
+				break;
+			}
+			case 1:
+			{
+				ramaddr = 0x10000;
+				break;
+			}
+			case 3:
+			{
+				ramaddr = 0x18000;
+				break;
+			}
+			default:
+				LOG_ERROR(" unknow CH56X riscvchip");
+				goto error_wlink;
+				
+			}
+
+			break;
+		}
+		case 5:{			
+			riscvchip = 0x05;
+			chipiaddr = 0x08000000;
+			pagesize = 256;
+			txbuf[3] = 0x03;
+			len = 4;
+			pWriteData(0, 1, txbuf, &len);
+			len = 4;
+			pReadData(0, 1, rxbuf, &len);
+			// txbuf[0] = 0x81;
+			// txbuf[1] = 0x06;
+			// txbuf[2] = 0x01;
+			// txbuf[3] = 0x01;
+			// len = 4;
+			// pWriteData(0, 1, txbuf, &len);
+			// len = 4;
+			// pReadData(0, 1, rxbuf, &len);
+			// if(rxbuf[2]==rxbuf[3]==1){
+			// 	LOG_ERROR("Read-Protect Status Currently Enabled");
+			// 	 goto error_wlink;
+			// 	}
+			break;
+		}
+		case 6:
+		{
+			riscvchip = 0x06;
+			chipiaddr = 0x08000000;
+			pagesize = 256;
+			txbuf[3] = 0x03;
+			len = 4;
+			pWriteData(0, 1, txbuf, &len);
+			len = 4;
+			pReadData(0, 1, rxbuf, &len);
+			// txbuf[0] = 0x81;
+			// txbuf[1] = 0x06;
+			// txbuf[2] = 0x01;
+			// txbuf[3] = 0x01;
+			// len = 4;
+			// pWriteData(0, 1, txbuf, &len);
+			// len = 4;
+			// pReadData(0, 1, rxbuf, &len);
+			// if(rxbuf[2]==rxbuf[3]==1){
+			// 	LOG_ERROR("Read-Protect Status Currently Enabled");
+			// 	 goto error_wlink;
+			// }
+			break;
+		}
+		case 7: // 
+		{
+			riscvchip = 0x02;
+			chipiaddr = 0x00000000;
+			pagesize = 256;
+			LOG_WARNING(" The debug interface has been opened,there is a risk of code leakage ,ensure that the debug interface has been closed before leaving factory !");
+			break;
+		}
+		case 9: // 
+		{
+			riscvchip = 0x09;
+			chipiaddr = 0x08000000;
+			pagesize = 64;
+			txbuf[3] = 0x03;
+			len = 4;
+			pWriteData(0, 1, txbuf, &len);
+			len = 4;
+			pReadData(0, 1, rxbuf, &len);
+			// txbuf[0] = 0x81;
+			// txbuf[1] = 0x06;
+			// txbuf[2] = 0x01;
+			// txbuf[3] = 0x01;
+			// len = 4;
+			// pWriteData(0, 1, txbuf, &len);
+			// len = 4;
+			// pReadData(0, 1, rxbuf, &len);
+			// if(rxbuf[2]==rxbuf[3]==1){
+			// 	LOG_ERROR("Read-Protect Status Currently Enabled");
+			// 	 goto error_wlink;
+			// }			
+			break;
+		}
+		case 0x0a:
+		{
+			riscvchip = 0x0a;
+			chipiaddr = 0x00000000;
+			pagesize = 256;
+			txbuf[3] = 0x03;
+			len = 4;
+			pWriteData(0, 1, txbuf, &len);
+			len = 4;
+			pReadData(0, 1, rxbuf, &len);
+			
+			break;
+		}
+		default:
+			LOG_ERROR(" communication fail,please contact [support@mounriver.com]");
+			goto error_wlink;
+		}
+#ifdef _WIN32
+		gOpen = TRUE;
+#endif
+	}
+	else
+	{
+		return ERROR_FAIL;
+	}
+	LOG_INFO("wlink_init ok");
+	return ERROR_OK;
+#ifdef _WIN32
+error_wlink:
+	
+	wlink_endprocess();
+	pCloseDev(gIndex);
+	if (hModule)
+	{
+		FreeLibrary(hModule);
+		hModule = 0;
+	}
+	return ERROR_FAIL;
+#else
+error_wlink:
+	if(wfd){
+		
+		wlink_endprocess();
+		jtag_libusb_close(wfd);
+	}
+	return ERROR_FAIL;
+#endif
+}
+
+int wlink_quit(void)
+{
+#ifdef _WIN32
+	if (gOpen)
+	{	wlink_endprocess();
+		pCloseDev(gIndex);
+		gOpen = FALSE;
+	}
+	if (hModule)
+	{
+		FreeLibrary(hModule);
+		hModule = 0;
+	}
+#else if
+	wlink_endprocess();
+	jtag_libusb_close(wfd);
+#endif
+	return ERROR_OK;
+}
+
+void wlink_disabledebug(void)
+{
+	if ((riscvchip == 0x02) || (riscvchip == 0x03))
+	{
+		unsigned char txbuf[4];
+		unsigned char rxbuf[4];
+		unsigned long len = 4;
+		txbuf[0] = 0x81;
+		txbuf[1] = 0x0e;
+		txbuf[2] = 0x01;
+		txbuf[3] = 0x01;
+		len = 4;
+		pWriteData(0, 1, txbuf, &len);
+		len = 4;
+		pReadData(0, 1, rxbuf, &len);
+	}
+	
+}
+
+
+
+int wlink_write(const uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	int packsize=4096;
+	
+	if(riscvchip==0x09)
+		packsize=1024;
+	uint8_t* buf_bin;
+	buf_bin=malloc(packsize);
+	memset(buf_bin,0xff,packsize);
+	
+	int binlength = count;
+	wlink_ready_write(offset,count);
+	
+	if (binlength <= packsize)
+	{
+		for (int i = 0; i < count; i++)
+		{
+			buf_bin[i] = *(buffer + i);
+		}
+		int ret = wlink_fastprogram(buf_bin,packsize);
+		if (ret != ERROR_OK)
+		{
+			return ERROR_FAIL;
+		}
+	}
+	else
+	{
+		while (binlength >= packsize)
+		{
+			for (int i = 0; i < packsize; i++)
+			{
+				buf_bin[i] = *(buffer + i);
+			}
+			int ret = wlink_fastprogram(buf_bin,packsize);
+			if (ret != ERROR_OK)
+			{
+				return ERROR_FAIL;
+			}
+			binlength -= packsize;
+			buffer += packsize;
+		}
+		if (binlength > 0)
+		{
+			memset(buf_bin,0xff,packsize);
+			for (int i = 0; i < binlength; i++)
+			{
+				buf_bin[i] = *(buffer + i);
+			}
+			int ret = wlink_fastprogram(buf_bin,packsize);
+			if (ret != ERROR_OK)
+			{
+				return ERROR_FAIL;
+			}
+		}
+	}
+	wlink_endprogram();
+	return ERROR_OK;
+}
+
+
+/*ARM*/
+
+
+
+
+
+COMMAND_HANDLER(wlink_set_address)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], wlink_address );
+	
+	return ERROR_OK;
+}
+
+
+
+
+
+
+COMMAND_HANDLER(wlink_set_index)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], gIndex);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(wlink_set)
+{
+	wchwlink=true;
+	return ERROR_OK;
+}
+COMMAND_HANDLER(noload)
+{
+	noloadflag=1;
+	return ERROR_OK;
+}
+COMMAND_HANDLER(page_erase)
+{
+	pageerase=true;
+	return ERROR_OK;
+}
+static const struct command_registration wlink_command_handlers[] = {
+	{
+		.name = "wlink_set_index",
+		.handler = &wlink_set_index,
+		.mode = COMMAND_CONFIG,
+		.help = "wlink_set_index num",
+		.usage = "set Wlink index",
+	},
+	{
+		.name = "wlink_set",
+		.handler = &wlink_set,
+		.mode = COMMAND_CONFIG,
+		.help = "wlink_set",
+		.usage = "",
+	},
+	{
+		.name = "wlink_set_address",
+		.handler = &wlink_set_address,
+		.mode = COMMAND_CONFIG,
+		.help = "wlink_set_address num",
+		.usage = "set Wlink address",
+	},
+	{
+		.name = "noload",
+		.handler = &noload,
+		.mode = COMMAND_CONFIG,
+		.help = "noload",
+		.usage = "dont download",
+	},
+	{
+		.name = "page_erase",
+		.handler = &page_erase,
+		.mode = COMMAND_CONFIG,
+		.help = "page_erase",
+		.usage = "page erase",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static struct jtag_interface wlink_interface = {
+	
+	.supported = DEBUG_CAP_TMS_SEQ,
+	.execute_queue = wlink_execute_queue,
+};
+struct adapter_driver wlink_adapter_driver = {
+	.name = "wlink",
+
+	.commands = wlink_command_handlers,
+	.transports = jtag_only,
+
+	.init = wlink_init,
+	.quit = wlink_quit,
+	.jtag_ops = &wlink_interface,
+};
diff -Nur openocd/src/jtag/interfaces.c openocd.new/src/jtag/interfaces.c
--- openocd/src/jtag/interfaces.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/jtag/interfaces.c	2024-11-23 18:12:06.619366660 +0800
@@ -20,6 +20,9 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+#if BUILD_WLINK == 1
+extern struct adapter_driver wlink_adapter_driver;
+#endif
 
 #include "interfaces.h"
 
@@ -141,12 +144,16 @@
 #if BUILD_XDS110 == 1
 		&xds110_adapter_driver,
 #endif
+
 #if BUILD_HLADAPTER_STLINK == 1
 		&stlink_dap_adapter_driver,
 #endif
 #if BUILD_RSHIM == 1
 		&rshim_dap_adapter_driver,
 #endif
+#if BUILD_WLINK == 1
+		&wlink_adapter_driver,
+#endif
 #if BUILD_DMEM == 1
 		&dmem_dap_adapter_driver,
 #endif
diff -Nur openocd/src/openocd.c openocd.new/src/openocd.c
--- openocd/src/openocd.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/openocd.c	2024-11-23 18:12:06.619366660 +0800
@@ -282,7 +282,7 @@
 static int openocd_thread(int argc, char *argv[], struct command_context *cmd_ctx)
 {
 	int ret;
-
+	
 	if (parse_cmdline_args(cmd_ctx, argc, argv) != ERROR_OK)
 		return ERROR_FAIL;
 
@@ -310,8 +310,7 @@
 		}
 	}
 
-	ret = server_loop(cmd_ctx);
-
+	ret = server_loop(cmd_ctx);	
 	int last_signal = server_quit();
 	if (last_signal != ERROR_OK)
 		return last_signal;
diff -Nur openocd/src/server/gdb_server.c openocd.new/src/server/gdb_server.c
--- openocd/src/server/gdb_server.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/server/gdb_server.c	2024-11-23 18:13:29.365609204 +0800
@@ -49,6 +49,14 @@
  * giving GDB access to the JTAG or other hardware debugging facilities
  * found in most modern embedded processors.
  */
+extern bool wchwlink;
+extern uint32_t chip_type;
+extern int wlink_quitreset(void);
+extern unsigned char riscvchip;
+extern uint8_t armchip;
+extern void wlink_armquitreset(struct cmsis_dap *dap);
+extern int wlink_address;
+
 
 enum gdb_output_flag {
 	/* GDB doesn't accept 'O' packets */
@@ -1088,7 +1096,7 @@
 
 	return ERROR_OK;
 }
-
+extern void wlink_endprocess(void);
 static int gdb_connection_closed(struct connection *connection)
 {
 	struct target *target;
@@ -1125,7 +1133,8 @@
 	target_call_event_callbacks(target, TARGET_EVENT_GDB_END);
 
 	target_call_event_callbacks(target, TARGET_EVENT_GDB_DETACH);
-
+   if(wchwlink)
+       wlink_endprocess();
 	return ERROR_OK;
 }
 
@@ -1639,7 +1648,9 @@
 	packet++;
 
 	addr = strtoull(packet, &separator, 16);
-
+	if((addr>=0x08000000)&&(wlink_address!=0x08000000)&&(addr<=0x20000000)){
+		return ERROR_SERVER_REMOTE_CLOSED;
+	}
 	if (*separator != ',') {
 		LOG_ERROR("incomplete write memory binary packet received, dropping connection");
 		return ERROR_SERVER_REMOTE_CLOSED;
@@ -1741,9 +1752,22 @@
 	int retval;
 
 	LOG_DEBUG("[%s]", target_name(target));
-
 	type = strtoul(packet + 1, &separator, 16);
-
+	if(wchwlink){
+		if((riscvchip==6 ||(((uint16_t)chip_type) ==0x050c)) && type==1 && target->breakpoints ){
+			struct breakpoint *p= target->breakpoints->next;
+			int len=0;
+			while(p){
+				len++;
+				p=p->next;
+			}
+			if(len>2)
+				type=0;		
+		}
+		if(riscvchip==1||riscvchip==2||riscvchip==3 ||riscvchip==9 ||riscvchip==0x0a ||((uint16_t)chip_type) ==0x0500){
+			type=0;
+		}
+	}
 	if (type == 0)	/* memory breakpoint */
 		bp_type = BKPT_SOFT;
 	else if (type == 1)	/* hardware breakpoint */
@@ -3241,7 +3265,7 @@
 	gdb_put_packet(connection, "S00", 3);
 	return true;
 }
-
+extern struct cmsis_dap *cmsis_dap_handle;
 static int gdb_v_packet(struct connection *connection,
 		char const *packet, int packet_size)
 {
@@ -3262,6 +3286,13 @@
 
 		return ERROR_OK;
 	}
+	if (strncmp(packet, "vKill", 5) == 0){
+		if(riscvchip){
+			wlink_quitreset();
+		}else if(armchip){
+			wlink_armquitreset(cmsis_dap_handle);
+			}
+	} 
 
 	if (strncmp(packet, "vRun", 4) == 0) {
 		bool handled;
@@ -3283,7 +3314,13 @@
 	if (strncmp(packet, "vFlashErase:", 12) == 0) {
 		target_addr_t addr;
 		unsigned long length;
-
+		if(wchwlink){
+			// if(riscvchip==1||riscvchip==6)
+			// {	
+				gdb_put_packet(connection, "OK", 2);
+				return ERROR_OK;
+			// }
+		}
 		char const *parse = packet + 12;
 		if (*parse == '\0') {
 			LOG_ERROR("incomplete vFlashErase packet received, dropping connection");
@@ -3505,7 +3542,6 @@
 	int retval;
 	struct gdb_connection *gdb_con = connection->priv;
 	static bool warn_use_ext;
-
 	target = get_target_from_connection(connection);
 
 	/* drain input buffer. If one of the packets fail, then an error
@@ -3662,12 +3698,13 @@
 					retval = gdb_write_memory_binary_packet(connection, packet, packet_size);
 					gdb_con->output_flag = GDB_OUTPUT_NO;
 					break;
-				case 'k':
+				case 'k':					
 					if (gdb_con->extended_protocol) {
 						gdb_con->attached = false;
 						break;
 					}
 					gdb_put_packet(connection, "OK", 2);
+
 					return ERROR_SERVER_REMOTE_CLOSED;
 				case '!':
 					/* handle extended remote protocol */
diff -Nur openocd/src/server/Makefile.am openocd.new/src/server/Makefile.am
--- openocd/src/server/Makefile.am	2023-01-15 17:56:19.000000000 +0800
+++ openocd.new/src/server/Makefile.am	2024-11-23 18:12:06.619366660 +0800
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 noinst_LTLIBRARIES += %D%/libserver.la
+%C%_libserver_la_CPPFLAGS = $(AM_CPPFLAGS) -Wno-incompatible-pointer-types
 %C%_libserver_la_SOURCES = \
 	%D%/server.c \
 	%D%/telnet_server.c \
diff -Nur openocd/src/target/riscv/Makefile.am openocd.new/src/target/riscv/Makefile.am
--- openocd/src/target/riscv/Makefile.am	2023-01-15 17:56:19.000000000 +0800
+++ openocd.new/src/target/riscv/Makefile.am	2024-11-23 18:12:06.620366652 +0800
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 noinst_LTLIBRARIES += %D%/libriscv.la
+%C%_libriscv_la_CPPFLAGS = $(AM_CPPFLAGS) -Wno-incompatible-pointer-types
 %C%_libriscv_la_SOURCES = \
        %D%/asm.h \
        %D%/batch.h \
diff -Nur openocd/src/target/riscv/riscv-013.c openocd.new/src/target/riscv/riscv-013.c
--- openocd/src/target/riscv/riscv-013.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/target/riscv/riscv-013.c	2024-11-23 18:20:35.777658655 +0800
@@ -28,7 +28,27 @@
 #include "program.h"
 #include "asm.h"
 #include "batch.h"
+#define RVFNIC_CTRLR 0xE000E048
+#define NVIC_KEY 0xBEEF0000
 
+extern unsigned char	DMI_OP( 
+	unsigned long	iIndex,  
+	unsigned char	iAddr,       
+	unsigned long	iData,
+	unsigned char	iOP,       
+	unsigned char*	oAddr,       
+	unsigned long*	oData,      
+	unsigned char*  oOP );  
+extern unsigned char WriteNonFullPage(unsigned long iaddr,
+									 unsigned char* ibuff,
+									 unsigned long ilen);
+
+static int execute_fence(struct target *target);
+extern unsigned char riscvchip;
+extern int server_quit(void);
+extern unsigned long ramaddr;
+uint32_t flashaddr=0;
+extern bool wchwlink;
 static int riscv013_on_step_or_resume(struct target *target, bool step);
 static int riscv013_step_or_resume_current_hart(struct target *target,
 		bool step, bool use_hasel);
@@ -212,6 +232,11 @@
 
 	/* DM that provides access to this target. */
 	dm013_info_t *dm;
+
+  uint32_t flash_start_addr;
+  uint32_t  flash_len;
+  uint32_t  flash_offset;
+  uint8_t flash_data[256];
 } riscv013_info_t;
 
 static LIST_HEAD(dm_list);
@@ -223,7 +248,102 @@
 	assert(info->version_specific);
 	return info->version_specific;
 }
+static int flush_flash_data(struct target *target)
+{
+	uint64_t regs[31];
+	uint64_t s0; 
+	uint64_t ra;
+	uint64_t sp;
+	uint64_t gp;
+	uint64_t tp;
+	uint64_t a0;
+	uint64_t a4;
+	uint64_t a5;
+	uint64_t a6;
+	uint64_t a7;
+	uint64_t s2;
+	uint64_t s3;
+	uint64_t s4;
+	uint64_t s5;
+	uint64_t s6;
+	uint64_t s7;
+	uint64_t s8;
+	uint64_t s9;
+	uint64_t s10;
+	uint64_t s11;
+	uint64_t t4;
+	uint64_t t5;
+	uint64_t t6;	
+	uint64_t t0;
+	uint64_t t1;
+	uint64_t t2;
+	uint64_t t3;	
+	uint64_t s1; 
+	uint64_t a1; 
+	uint64_t a2; 
+	uint64_t a3; 
+	RISCV013_INFO(info);
+	//write 
+	if(info->flash_len)
+	{	
+		execute_fence(target);					
+	    register_read_direct(target, &a0, GDB_REGNO_A0);					
+		// register_read_direct(target, &s0, GDB_REGNO_S0);
+		// register_read_direct(target, &ra, GDB_REGNO_RA);
+		// register_read_direct(target, &sp, GDB_REGNO_SP);
+		// register_read_direct(target, &gp, GDB_REGNO_GP);		
+		// register_read_direct(target, &t0, GDB_REGNO_T0);
+		// register_read_direct(target, &t1, GDB_REGNO_T1);
+	    // register_read_direct(target, &t2, GDB_REGNO_T2);
+		// register_read_direct(target, &t3, GDB_REGNO_T3);		
+		register_read_direct(target, &s1, GDB_REGNO_S1); 
+		register_read_direct(target, &a1, GDB_REGNO_A1);
+		register_read_direct(target, &a2, GDB_REGNO_A2);
+		register_read_direct(target, &a3, GDB_REGNO_A3);
+		register_read_direct(target, &a4, GDB_REGNO_A4);	
+		WriteNonFullPage(info->flash_start_addr,info->flash_data,info->flash_len);	
+	    register_write_direct(target, GDB_REGNO_A0, a0);	
+		// register_write_direct(target, GDB_REGNO_S0, s0);
+		// register_write_direct(target, GDB_REGNO_RA, ra);
+		// register_write_direct(target, GDB_REGNO_SP, sp);
+		// register_write_direct(target, GDB_REGNO_GP, gp);		
+		// register_write_direct(target, GDB_REGNO_T0, t0);
+		// register_write_direct(target, GDB_REGNO_T1, t1);
+		// register_write_direct(target, GDB_REGNO_T2, t2);
+		// register_write_direct(target, GDB_REGNO_T3, t3);
+		register_write_direct(target, GDB_REGNO_S1, s1);
+		register_write_direct(target, GDB_REGNO_A1, a1);
+		register_write_direct(target, GDB_REGNO_A2, a2);
+		register_write_direct(target, GDB_REGNO_A3, a3);
+		register_write_direct(target, GDB_REGNO_A4, a4);		
+	info->flash_start_addr = 0;
+	info->flash_len = 0;
+	info->flash_offset = 0;
+	memset(info->flash_data,0,sizeof(info->flash_data));
+	}
+}
+int write_flash_data(struct target *target, target_addr_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	uint32_t total_len;
+	uint32_t start_address,temp,temp1;
+	uint8_t * start_buffer;
+	RISCV013_INFO(info);	
+	start_address = address;
+	start_buffer = buffer;
+	total_len = size*count;
+    info->flash_start_addr = start_address;
+	info->flash_len = total_len;
+	info->flash_offset = total_len; 				
+	memcpy(info->flash_data,start_buffer,total_len);				
+	if(total_len <=4)  
+		{
+			flush_flash_data(target);
+			return 0;
+		}
 
+	return 0;
+}
 /**
  * Return the DM structure for this target. If there isn't one, find it in the
  * global list of DMs. If it's not in there, then create one and initialize it
@@ -441,6 +561,9 @@
 	}
 
 	uint32_t in = buf_get_u32(field.in_value, 0, 32);
+	if(wchwlink){
+		buf_set_u32(&in, 0, 32, 0x00000071);
+	}
 	LOG_DEBUG("DTMCS: 0x%x -> 0x%x", out, in);
 
 	return in;
@@ -456,7 +579,73 @@
 
 	dtmcontrol_scan(target, DTM_DTMCS_DMIRESET);
 }
+static int wlink_dmi_op_timeout(struct target *target, uint32_t *data_in,
+		bool *dmi_busy_encountered, int dmi_op, uint32_t address,
+		uint32_t data_out, int timeout_sec, bool exec, bool ensure_success)
+{
+	dmi_status_t status;
+	uint32_t address_in;
+	uint8_t	recvOP;
+	uint32_t recvData;
+	if (dmi_busy_encountered)
+		*dmi_busy_encountered = false;
+	
+	jtag_execute_queue();  
+	
+	const char *op_name;
+	switch (dmi_op) {
+		case DMI_OP_NOP:
+			op_name = "nop";
+			break;
+		case DMI_OP_READ:
+			op_name = "read";
+			break;
+		case DMI_OP_WRITE:
+			op_name = "write";
+			break;
+		default:
+			LOG_ERROR("Invalid DMI operation: %d", dmi_op);
+			return ERROR_FAIL;
+	}
+
+	time_t start = time(NULL);
+	int result=0;
+	/* This first loop performs the request.  Note that if for some reason this
+	 * stays busy, it is actually due to the previous access. */
+	while (1) {
+		if(dmi_op == DMI_OP_READ)
+		{
+			result=DMI_OP(0, (unsigned char	)address, 0, (unsigned char	)dmi_op, &address_in, data_in,&recvOP);
+			if(!result){
+					LOG_ERROR("failed %s at 0x%x, status=%d", op_name, address, status);
+					LOG_ERROR("Maybe the device has been removed");
+					server_quit();
+					return ERROR_FAIL;
+				}		
+		}else{
+			DMI_OP(0, (unsigned char	)address, data_out, (unsigned char	)dmi_op, &address_in, &recvData,&recvOP);
+		}
+		status = recvOP;
+		if (status == DMI_STATUS_BUSY) {
+			increase_dmi_busy_delay(target);
+			if (dmi_busy_encountered)
+				*dmi_busy_encountered = true;
+			DMI_OP(0, (unsigned char	)DM_ABSTRACTCS, DM_ABSTRACTCS_CMDERR, (unsigned char	)DMI_OP_WRITE, &address_in, &recvData,&recvOP);
+		} else if (status == DMI_STATUS_SUCCESS) {
+			break;
+		} else {
+			return ERROR_FAIL;
+		}
+		if (time(NULL) - start > timeout_sec)
+			return ERROR_TIMEOUT_REACHED;
+	}
 
+	if (status != DMI_STATUS_SUCCESS) {
+		LOG_ERROR("Failed %s at 0x%x; status=%d", op_name, address, status);
+		return ERROR_FAIL;
+	}
+	return ERROR_OK;
+}
 /**
  * exec: If this is set, assume the scan results in an execution, so more
  * run-test/idle cycles may be required.
@@ -557,6 +746,13 @@
 		bool *dmi_busy_encountered, int dmi_op, uint32_t address,
 		uint32_t data_out, int timeout_sec, bool exec, bool ensure_success)
 {
+	int ret=1;
+	if(wchwlink){
+			ret=wlink_dmi_op_timeout(target,data_in,dmi_busy_encountered,dmi_op,address,data_out,timeout_sec,exec,ensure_success);
+	}
+	if(ret==ERROR_OK){
+		return ret;
+	}
 	select_dmi(target);
 
 	dmi_status_t status;
@@ -667,7 +863,7 @@
 	return dmi_op(target, value, NULL, DMI_OP_READ, address, 0, true, true);
 }
 
-static int dmi_write(struct target *target, uint32_t address, uint32_t value)
+static  int dmi_write(struct target *target, uint32_t address, uint32_t value)
 {
 	return dmi_op(target, NULL, NULL, DMI_OP_WRITE, address, value, false, true);
 }
@@ -687,6 +883,7 @@
 		return result;
 	int dmstatus_version = get_field(*dmstatus, DM_DMSTATUS_VERSION);
 	if (dmstatus_version != 2 && dmstatus_version != 3) {
+	if(riscvchip != 9)
 		LOG_ERROR("OpenOCD only supports Debug Module version 2 (0.13) and 3 (1.0), not "
 				"%d (dmstatus=0x%x). This error might be caused by a JTAG "
 				"signal issue. Try reducing the JTAG clock speed.",
@@ -1594,10 +1791,12 @@
 		dmi_write(target, DM_DMCONTROL, DM_DMCONTROL_DMACTIVE);
 		dm->was_reset = true;
 	}
-
-	dmi_write(target, DM_DMCONTROL, DM_DMCONTROL_HARTSELLO |
+	if(!wchwlink)
+	{
+		dmi_write(target, DM_DMCONTROL, DM_DMCONTROL_HARTSELLO |
 			DM_DMCONTROL_HARTSELHI | DM_DMCONTROL_DMACTIVE |
 			DM_DMCONTROL_HASEL);
+	}
 	uint32_t dmcontrol;
 	if (dmi_read(target, &dmcontrol, DM_DMCONTROL) != ERROR_OK)
 		return ERROR_FAIL;
@@ -1732,6 +1931,9 @@
 	else
 		r->xlen = 32;
 
+  	if(wchwlink)
+    		r->xlen = 32;
+
 	if (register_read(target, &r->misa, GDB_REGNO_MISA)) {
 		LOG_ERROR("Fatal: Failed to read MISA from hart %d.", r->current_hartid);
 		return ERROR_FAIL;
@@ -2331,18 +2533,22 @@
 	info->abstract_write_fpr_supported = true;
 
 	info->has_aampostincrement = YNM_MAYBE;
-
+	info->flash_start_addr = 0;
+	info->flash_len = 0;
+	info->flash_offset = 0;
 	return ERROR_OK;
 }
 
 static int assert_reset(struct target *target)
 {
 	RISCV_INFO(r);
-
+	
 	select_dmi(target);
 
 	uint32_t control_base = set_field(0, DM_DMCONTROL_DMACTIVE, 1);
 
+	target->reset_halt = 1;
+
 	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
 		/* Run the user-supplied script if there is one. */
 		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
@@ -2390,6 +2596,7 @@
 	RISCV_INFO(r);
 	RISCV013_INFO(info);
 	select_dmi(target);
+  target->reset_halt = 1;
 
 	/* Clear the reset, but make sure haltreq is still set */
 	uint32_t control = 0, control_haltreq;
@@ -2412,7 +2619,6 @@
 		} else {
 			index = r->current_hartid;
 		}
-
 		LOG_DEBUG("Waiting for hart %d to come out of reset.", index);
 		while (1) {
 			int result = dmstatus_read_timeout(target, &dmstatus, true,
@@ -2424,6 +2630,9 @@
 						index, riscv_reset_timeout_sec);
 			if (result != ERROR_OK)
 				return result;
+			if(wchwlink)
+				break;
+			
 			/* Certain debug modules, like the one in GD32VF103
 			 * MCUs, violate the specification's requirement that
 			 * each hart is in "exactly one of four states" and,
@@ -2454,9 +2663,28 @@
 			break;
 	}
 	info->dmi_busy_delay = dmi_busy_delay;
+	
+	uint64_t tmpDcsr;
+	int res = register_read_direct(target, &tmpDcsr, GDB_REGNO_DCSR);
+	if(res != ERROR_OK){
+		LOG_DEBUG("[wch] dcsr read fail!");
+	}
+	else{
+		LOG_DEBUG("[wch] read dcsr value is 0x%x", tmpDcsr);
+		//enable ebreak in m&u mode
+		tmpDcsr = set_field(tmpDcsr, CSR_DCSR_EBREAKM, 1);
+		tmpDcsr = set_field(tmpDcsr, CSR_DCSR_EBREAKU, 1);		
+		res = register_write_direct(target, GDB_REGNO_DCSR, tmpDcsr);
+		register_read_direct(target, &tmpDcsr, GDB_REGNO_DCSR);
+		if(res == ERROR_OK){			
+		}
+		else{
+			LOG_DEBUG("[wch] dcsr write fail");
+			assert(false);
+		}
+	}
 	return ERROR_OK;
 }
-
 static int execute_fence(struct target *target)
 {
 	/* FIXME: For non-coherent systems we need to flush the caches right
@@ -3136,6 +3364,8 @@
 	if (dmi_write(target, DM_ABSTRACTAUTO,
 			1 << DM_ABSTRACTAUTO_AUTOEXECDATA_OFFSET) != ERROR_OK)
 		goto error;
+	result=ERROR_FAIL;
+	goto error;
 	/* Read garbage from dmi_data0, which triggers another execution of the
 	 * program. Now dmi_data0 contains the first good result, and s1 the next
 	 * memory value. */
@@ -3903,10 +4133,12 @@
 				}
 
 				/* Turn on autoexec */
-				dmi_write(target, DM_ABSTRACTAUTO,
-						1 << DM_ABSTRACTAUTO_AUTOEXECDATA_OFFSET);
+				if(!wchwlink)
+					{	dmi_write(target, DM_ABSTRACTAUTO,
+							1 << DM_ABSTRACTAUTO_AUTOEXECDATA_OFFSET);
 
-				setup_needed = false;
+					setup_needed = false;
+					}
 			} else {
 				if (size > 4)
 					riscv_batch_add_dmi_write(batch, DM_DATA1, value >> 32);
@@ -3979,12 +4211,82 @@
 
 static int write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
-{
+{	
+	
 	if (size != 1 && size != 2 && size != 4 && size != 8 && size != 16) {
 		LOG_ERROR("BUG: Unsupported size for memory write: %d", size);
 		return ERROR_FAIL;
 	}
-
+	if(address < 0x20000000)
+	{	
+		if(riscvchip==0x03){		
+		  uint64_t actual_value;
+		  uint8_t txbuffer[4];
+		  uint32_t  length;		
+		  if((address >= ramaddr)){
+					LOG_ERROR("THIS  ADDRESS IS NOT ACCESSIBLE");
+					server_quit();
+					return ERROR_FAIL;																												
+			}										
+			target_addr_t flashaddress=address;
+			if(address < ramaddr)
+			{					
+				if((size*count)==4){						
+			  		  if(address%4==0){
+			  		  	read_memory_progbuf_one(target, address, 4, (uint8_t*)&actual_value );		  			
+			  		  	write_memory_progbuf(target, address, 4, 1, buffer);	  	
+			  		  }else{	
+			  		  	   address=address-2;
+			  			   read_memory_progbuf_one(target, address, 4, (uint8_t*)&actual_value );		  			
+			  		  	   txbuffer[0]= ((uint32_t)actual_value)&0x000000ff;
+			  			   txbuffer[1]= (((uint32_t)actual_value)&0x0000ff00)>>8;
+			  			   txbuffer[2]= *buffer;
+			  			   txbuffer[3]= *(buffer+1);	  			
+			  		  	   write_memory_progbuf(target, address, 4, 1, &txbuffer);			  		  	 
+			  		  	   address=address+2;
+			  		  	   read_memory_progbuf_one(target, address, 4, (uint8_t*)&actual_value );			  		 
+			  		  	   txbuffer[0]= *(buffer+2);
+			  		   	   txbuffer[1]= *(buffer+3);
+			  			   txbuffer[2]= (((uint32_t)actual_value)&0x00ffffff)>>16;
+			  			   txbuffer[3]=((uint32_t)actual_value)>>24;		  		
+			  		  	   write_memory_progbuf(target, address, 4, 1, &txbuffer);
+			  		  	}	  
+				}else{		
+					if((size*count)!=2){
+						
+			  		}else{			  			
+			  			read_memory_progbuf_one(target, 0x0000, 4, (uint8_t*)&actual_value );				  
+			  			if(address%4==0){
+			  			read_memory_progbuf_one(target, address, 4, (uint8_t*)&actual_value );			  		
+			  			txbuffer[0]= *buffer;
+			  			txbuffer[1]= *(buffer+1);
+			  			txbuffer[2]= (((uint32_t)actual_value)&0x00ffffff)>>16;
+			  			txbuffer[3]=((uint32_t)actual_value)>>24;		  		
+			  			write_memory_progbuf(target, address, 4, 1, &txbuffer);
+			  			}else{
+			  					address=address-2;
+			  					read_memory_progbuf_one(target, address, 4, (uint8_t*)&actual_value );			  				
+			  			    txbuffer[0]= ((uint32_t)actual_value)&0x000000ff;
+			  			    txbuffer[1]= (((uint32_t)actual_value)&0x0000ff00)>>8;
+			  			    txbuffer[2]= *buffer;
+			  			    txbuffer[3]= *(buffer+1);			  		
+			  				write_memory_progbuf(target, address, 4, 1, &txbuffer);		
+			  			 }	  	
+						}				
+				}
+			}
+								
+			//write_flash_data(target, flashaddress, size, count, buffer);			
+		}				
+		if((riscvchip==0x01)||(riscvchip==0x02)||(riscvchip==0x06)||(riscvchip==0x05)||(riscvchip==0x09)||(riscvchip==0x0a))
+		{			
+			if(address>=0x08000000)
+				address-=0x08000000;
+			write_flash_data(target, address, size, count, buffer);			
+		}
+		return ERROR_OK;
+	}else{
+	
 	int ret = ERROR_FAIL;
 	RISCV_INFO(r);
 	RISCV013_INFO(info);
@@ -4036,6 +4338,7 @@
 	LOG_ERROR("Target %s: Failed to write memory (addr=0x%" PRIx64 ")", target_name(target), address);
 	LOG_ERROR("  progbuf=%s, sysbus=%s, abstract=%s", progbuf_result, sysbus_result, abstract_result);
 	return ret;
+	}
 }
 
 static int arch_state(struct target *target)
@@ -4347,6 +4650,10 @@
 
 int riscv013_write_debug_buffer(struct target *target, unsigned int index, riscv_insn_t data)
 {
+	if(wchwlink){
+		if (dmi_write(target, DM_PROGBUF0 + index, data) != ERROR_OK)
+			return ERROR_FAIL;
+	}
 	dm013_info_t *dm = get_dm(target);
 	if (!dm)
 		return ERROR_FAIL;
@@ -4414,13 +4721,32 @@
 		return execute_fence(target);
 	return ERROR_OK;
 }
+int wlink_cleancache(struct target *target)
+{
+	uint64_t old_dpc_value,new_dpc_value,t6_new,t6_old;
+	uint32_t dmcontrol;
+	RISCV013_INFO(info);
 
+	{
+		struct riscv_program program;
+		register_read_direct(target, &t6_old, GDB_REGNO_T6);
+		register_write_direct(target, GDB_REGNO_T6, 4);  
+		riscv_program_init(&program, target);
+		riscv_program_insert(&program, 0x000f8067);      
+		int result = riscv_program_exec(&program, target);
+		usleep(1000);		
+		register_write_direct(target, GDB_REGNO_T6, t6_old);	
+	}
+	return ERROR_OK;
+}
 /* Helper Functions. */
 static int riscv013_on_step_or_resume(struct target *target, bool step)
 {
 	if (maybe_execute_fence_i(target) != ERROR_OK)
 		return ERROR_FAIL;
-
+	if((riscvchip==0x01)){
+		wlink_cleancache(target);
+	}
 	/* We want to twiddle some bits in the debug CSR so debugging works. */
 	riscv_reg_t dcsr;
 	int result = register_read(target, &dcsr, GDB_REGNO_DCSR);
@@ -4437,6 +4763,7 @@
 		bool step, bool use_hasel)
 {
 	RISCV_INFO(r);
+	
 	LOG_DEBUG("resuming hart %d (for step?=%d)", r->current_hartid, step);
 	if (!riscv_is_halted(target)) {
 		LOG_ERROR("Hart %d is not halted!", r->current_hartid);
@@ -4464,6 +4791,7 @@
 			continue;
 
 		dmi_write(target, DM_DMCONTROL, dmcontrol);
+	
 		return ERROR_OK;
 	}
 
diff -Nur openocd/src/target/riscv/riscv.c openocd.new/src/target/riscv/riscv.c
--- openocd/src/target/riscv/riscv.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/target/riscv/riscv.c	2024-11-23 18:12:06.622366636 +0800
@@ -23,6 +23,8 @@
 #include "debug_defines.h"
 #include <helper/bits.h>
 
+extern bool wchwlink;
+
 #define get_field(reg, mask) (((reg) & (mask)) / ((mask) & ~((mask) << 1)))
 #define set_field(reg, mask, val) (((reg) & ~(mask)) | (((val) * ((mask) & ~((mask) << 1))) & (mask)))
 
@@ -403,6 +405,9 @@
 	}
 
 	uint32_t in = buf_get_u32(field.in_value, 0, 32);
+	if(wchwlink){
+		buf_set_u32(&in, 0, 32, 0x00000071);
+	}
 	LOG_DEBUG("DTMCONTROL: 0x%x -> 0x%x", out, in);
 
 	return in;
@@ -583,7 +588,7 @@
 
 	return ERROR_OK;
 }
-
+extern unsigned char riscvchip; 
 static int maybe_add_trigger_t2(struct target *target,
 		struct trigger *trigger, uint64_t tdata1)
 {
@@ -596,7 +601,8 @@
 	}
 
 	/* address/data match trigger */
-	tdata1 |= MCONTROL_DMODE(riscv_xlen(target));
+	if(riscvchip==0)
+		tdata1 |= MCONTROL_DMODE(riscv_xlen(target));
 	tdata1 = set_field(tdata1, MCONTROL_ACTION,
 			MCONTROL_ACTION_DEBUG_MODE);
 	tdata1 = set_field(tdata1, MCONTROL_MATCH, MCONTROL_MATCH_EQUAL);
@@ -701,7 +707,6 @@
 	for (i = 0; i < r->trigger_count; i++) {
 		if (r->trigger_unique_id[i] != -1)
 			continue;
-
 		riscv_set_register(target, GDB_REGNO_TSELECT, i);
 
 		uint64_t tdata1;
@@ -894,7 +899,6 @@
 					TARGET_PRIxADDR, breakpoint->length, breakpoint->address);
 			return ERROR_FAIL;
 		}
-
 	} else if (breakpoint->type == BKPT_HARD) {
 		struct trigger trigger;
 		trigger_from_breakpoint(&trigger, breakpoint);
@@ -1275,6 +1279,17 @@
 	LOG_DEBUG("[%d]", target->coreid);
 	struct target_type *tt = get_target_type(target);
 	riscv_invalidate_register_cache(target);
+	if(wchwlink){
+		int ret=riscv_halt(target);
+		if(ret == ERROR_OK){
+			return tt->assert_reset(target);
+		}
+		else{
+			LOG_ERROR("[wch] hart must be halted before reset!");
+			return ERROR_FAIL;
+		}
+
+	}
 	return tt->assert_reset(target);
 }
 
@@ -3507,7 +3522,7 @@
 
 	riscv_set_register(target, GDB_REGNO_TSELECT, tselect);
 
-	LOG_INFO("[%s] Found %d triggers", target_name(target), r->trigger_count);
+	LOG_DEBUG("[%s] Found %d triggers", target_name(target), r->trigger_count);
 
 	return ERROR_OK;
 }
diff -Nur openocd/src/target/target.c openocd.new/src/target/target.c
--- openocd/src/target/target.c	2024-11-23 11:48:29.000000000 +0800
+++ openocd.new/src/target/target.c	2024-11-23 18:12:06.622366636 +0800
@@ -52,6 +52,11 @@
 /* default halt wait timeout (ms) */
 #define DEFAULT_HALT_TIMEOUT 5000
 
+
+extern unsigned char riscvchip;
+extern int wlink_reset();
+extern int wlink_quitreset(void);
+extern int wlink_verify(unsigned long length, unsigned char *buffer);
 static int target_read_buffer_default(struct target *target, target_addr_t address,
 		uint32_t count, uint8_t *buffer);
 static int target_write_buffer_default(struct target *target, target_addr_t address,
@@ -3281,7 +3286,6 @@
 
 	return ERROR_OK;
 }
-
 COMMAND_HANDLER(handle_reset_command)
 {
 	if (CMD_ARGC > 1)
@@ -3296,10 +3300,13 @@
 		reset_mode = n->value;
 	}
 
-	/* reset *all* targets */
 	return target_process_reset(CMD, reset_mode);
 }
-
+COMMAND_HANDLER(handle_wlink_reset_resume_command)
+{
+	
+	wlink_quitreset();
+}
 
 COMMAND_HANDLER(handle_resume_command)
 {
@@ -3768,11 +3775,14 @@
 	int retval;
 	uint32_t checksum = 0;
 	uint32_t mem_checksum = 0;
-
+	int i;
 	struct image image;
 
 	struct target *target = get_current_target(CMD_CTX);
-
+	if((riscvchip==0x03)||(riscvchip==0x02)||(riscvchip==0x01)){
+		wlink_reset();
+		
+	}
 	if (CMD_ARGC < 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
@@ -3803,6 +3813,45 @@
 	image_size = 0x0;
 	int diffs = 0;
 	retval = ERROR_OK;
+	if(riscvchip){
+		uint32_t  addr=0;
+		unsigned long length;
+        uint8_t *buffer1;
+		uint8_t *buffer2;
+
+		length=image.sections[image.num_sections-1].size + image.sections[image.num_sections-1].base_address;
+		
+		
+		buffer2=malloc(length+256);
+		memset(buffer2,0xff,length);
+		for (i = 0; i < image.num_sections; i++) {
+
+			buffer1 = malloc(image.sections[i].size);
+			retval = image_read_section(&image, i, 0x0, image.sections[i].size, buffer1, &buf_cnt);
+
+			for(int j=0;j<buf_cnt;j++){
+			buffer2[j+image.sections[i].base_address]=buffer1[j];
+
+			}
+	    }
+		if(length%64){
+			
+			for(int j=0;j<64-length%64;j++)
+			{
+				buffer2[length+j]=0xff;
+			}
+				length+= 64-length%64;
+			} 
+		
+		int ret=wlink_verify( length-image.sections[0].base_address, &buffer2[image.sections[0].base_address]);
+	
+	free(buffer2);
+	free(buffer1);
+	image_close(&image);
+	return ret;
+	
+}
+
 	for (unsigned int i = 0; i < image.num_sections; i++) {
 		buffer = malloc(image.sections[i].size);
 		if (!buffer) {
@@ -3823,8 +3872,7 @@
 			if (retval != ERROR_OK) {
 				free(buffer);
 				break;
-			}
-
+			}		 
 			retval = target_checksum_memory(target, image.sections[i].base_address, buf_cnt, &mem_checksum);
 			if (retval != ERROR_OK) {
 				free(buffer);
@@ -3837,14 +3885,13 @@
 				goto done;
 			}
 			if (checksum != mem_checksum) {
+				
 				/* failed crc checksum, fall back to a binary compare */
-				uint8_t *data;
 
+				uint8_t *data;
 				if (diffs == 0)
-					LOG_ERROR("checksum mismatch - attempting binary compare");
-
-				data = malloc(buf_cnt);
-
+					LOG_DEBUG("checksum mismatch - attempting binary compare");
+		 		data = malloc(buf_cnt);
 				retval = target_read_buffer(target, image.sections[i].base_address, buf_cnt, data);
 				if (retval == ERROR_OK) {
 					uint32_t t;
@@ -6588,6 +6635,13 @@
 			"Default reset mode is run, if not given.",
 	},
 	{
+		.name = "wlink_reset_resume",
+		.handler = handle_wlink_reset_resume_command,
+		.mode = COMMAND_EXEC,
+		.usage = "",
+		.help = "Reset && resume. ",
+	},
+	{
 		.name = "soft_reset_halt",
 		.handler = handle_soft_reset_halt_command,
 		.mode = COMMAND_EXEC,
diff -Nur openocd/tcl/interface/wlink.cfg openocd.new/tcl/interface/wlink.cfg
--- openocd/tcl/interface/wlink.cfg	1970-01-01 08:00:00.000000000 +0800
+++ openocd.new/tcl/interface/wlink.cfg	2024-11-23 18:12:06.622366636 +0800
@@ -0,0 +1,4 @@
+# Extracted from MRS wch-riscv.cfg to be just the "interface" portion
+adapter driver wlink
+wlink_set
+
diff -Nur openocd/tcl/target/wch-riscv.cfg openocd.new/tcl/target/wch-riscv.cfg
--- openocd/tcl/target/wch-riscv.cfg	1970-01-01 08:00:00.000000000 +0800
+++ openocd.new/tcl/target/wch-riscv.cfg	2024-11-23 18:12:06.622366636 +0800
@@ -0,0 +1,13 @@
+# Extracted from MRS wch-riscv.cfg, split to be just the _target_ portion
+set _CHIPNAME wch-rv
+
+jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x00001
+
+set _TARGETNAME $_CHIPNAME.cpu
+
+target create $_TARGETNAME.0 riscv -chain-position $_TARGETNAME
+$_TARGETNAME.0 configure  -work-area-phys 0x80000000 -work-area-size 10000 -work-area-backup 1
+set _FLASHNAME $_CHIPNAME.flash
+
+flash bank $_FLASHNAME wch_riscv 0x00000000 0 0 0 $_TARGETNAME.0
+
